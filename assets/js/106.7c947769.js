(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{388:function(t,n,e){"use strict";e.r(n);var a=e(10),r=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构-链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-链表"}},[t._v("#")]),t._v(" "),n("center",[t._v("数据结构-链表")])],1),t._v(" "),n("h2",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("由一系列节点（Node）组成，每个节点包含了存储的数据以及指向下一个节点的引用（指针或链接）。相比于数组，链表的大小可以动态地调整，并且在内存中不需要连续的空间。")]),t._v(" "),n("p",[t._v("链表通常分为单向链表和双向链表两种形式。")]),t._v(" "),n("h2",{attrs:{id:"单向链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单向链表"}},[t._v("#")]),t._v(" 单向链表")]),t._v(" "),n("p",[t._v("每个节点只包含一个指向下一个节点的引用。最后一个节点的引用指向空（null）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  +---------+    +---------+    +---------+    +---------+\n  |   Data  |    |   Data  |    |   Data  |    |   Data  |\n  |   Next  +---\x3e|   Next  +---\x3e|   Next  +---\x3e|   Null  |\n  +---------+    +---------+    +---------+    +---------+\n")])])]),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n)\n\ntype Chain struct {\n\tSize uint // 连边元素个数\n\tNext *Ele // 第0个元素\n}\ntype Ele struct {\n\tData interface{}\n\tNext *Ele\n}\n\n// 添加元素到尾部\nfunc (c *Chain) Push(data interface{}) {\n\tif c.Size == 0 { // 若链表是空的，直接赋值\n\t\tc.Next = &Ele{\n\t\t\tData: data,\n\t\t}\n\t\tc.Size++ // 记得链表长度加1\n\t\treturn\n\t}\n\tcurrent := c.Next\n\tfor current.Next != nil { // 找到最后一个元素，即没有Next的元素\n\t\tcurrent = current.Next\n\t}\n\tcurrent.Next = &Ele{ // 将新元素挂载到最后一个后面\n\t\tData: data,\n\t}\n\tc.Size++\n}\nfunc (c *Chain) Insert(index uint, data interface{}) {\n\tif index >= c.Size { // 长度大于size，直接使用push方法\n\t\tc.Push(data)\n\t\treturn\n\t}\n\tcurrent := c.Next\n\tele := Ele{\n\t\tData: data,\n\t}\n\tif index == 0 { // 若是插入到第一个，不用查找，直接挂载到链表next上\n\t\tele.Next = current\n\t\tc.Next = &ele\n\t\tc.Size++\n\t\treturn\n\t}\n\tvar count uint = 0\n\tfor count != index-1 {\n\t\tcurrent = current.Next\n\t\tcount++\n\t}\n\tele.Next = current.Next\n\tcurrent.Next = &ele\n\tc.Size++\n}\nfunc (c *Chain) Get(index uint) interface{} {\n\tif index >= c.Size { // 大于长度直接返回nil\n\t\treturn nil\n\t}\n\tvar count uint = 0\n\tcurrent := c.Next\n\tfor count != index {\n\t\tcurrent = current.Next\n\t\tcount++\n\t}\n\treturn current.Data\n}\nfunc (c *Chain) Set(index uint, data interface{}) {\n\tif index >= c.Size {\n\t\tc.Push(data)\n\t\treturn\n\t}\n\tvar count uint = 0\n\tcurrent := c.Next\n\tfor count != index {\n\t\tcurrent = current.Next\n\t\tcount++\n\t}\n\tcurrent.Data = data\n}\nfunc (c *Chain) Delete(index uint) (bool, string) {\n\tok := true\n\tmsg := ""\n\tif index >= c.Size {\n\t\tok = false\n\t\tmsg = "超过最大长度"\n\t\treturn ok, msg\n\t}\n\tvar count uint = 0\n\tcurrent := c.Next\n\tif index == 0 {\n\t\tc.Next = current.Next\n\t\tc.Size--\n\t\treturn ok, msg\n\t}\n\tfor count != index-1 {\n\t\tcurrent = current.Next\n\t\tcount++\n\t}\n\tcurrent.Next = current.Next.Next\n\tc.Size--\n\treturn ok, msg\n}\n\nfunc main() {\n\tchain := Chain{}\n\tfmt.Println(chain)\n\tchain.Push("第0个元素")\n\tchain.Push("第1个元素")\n\tchain.Push("第2个元素")\n\tchain.Push("第3个元素")\n\tfmt.Println(chain.Get(0))\n\tfmt.Println(chain.Get(1))\n\tfmt.Println(chain.Get(2))\n\tfmt.Println(chain.Get(3))\n\tfmt.Println(chain.Get(4))\n\tchain.Set(0, "修改第0个元素")\n\tchain.Set(4, "修改第4个元素")\n\tfmt.Println(chain.Get(0))\n\tfmt.Println(chain.Get(4))\n\tchain.Insert(0, "插入到头部")\n\tfmt.Println(chain.Get(0))\n\tfmt.Println(chain.Get(chain.Size - 1))\n\tchain.Delete(chain.Size - 1)\n\tfmt.Println(chain.Get(chain.Size - 1))\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("{0 <nil>}\n第0个元素    \n第1个元素    \n第2个元素    \n第3个元素    \n<nil>        \n修改第0个元素\n修改第4个元素\n插入到头部   \n修改第4个元素\n第3个元素  \n")])])]),n("h3",{attrs:{id:"循环链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#循环链表"}},[t._v("#")]),t._v(" 循环链表")]),t._v(" "),n("p",[t._v("大致和普通链表一致，将首位连接。注意头和尾的判断")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n)\n\ntype Chain struct {\n\tSize uint\n\thead *Ele\n}\ntype Ele struct {\n\tdata interface{}\n\tnext *Ele\n}\n\nfunc (c *Chain) Push(data interface{}) {\n\tele := &Ele{\n\t\tdata: data,\n\t}\n\tif c.Size == 0 {\n\t\tc.head = ele\n\t\tele.next = c.head // 尾链接到头\n\t\tc.Size++\n\t\treturn\n\t}\n\tcurrent := c.head\n\tfor current.next != c.head { // current.next == c.head 表示current是尾\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = ele\n\tele.next = c.head\n\tc.Size++\n}\n\nfunc (c *Chain) Insert(index uint, data interface{}) {\n\tif index >= c.Size {\n\t\tc.Push(data)\n\t\treturn\n\t}\n\tele := &Ele{\n\t\tdata: data,\n\t}\n\tif index == 0 {\n\t\tele.next = c.head\n\t\tc.head = ele\n\t\tc.Size++\n\t\treturn\n\t}\n\tvar count uint = 0\n\tcurrent := c.head\n\tfor count != index-1 {\n\t\tcurrent = current.next\n\t\tcount++\n\t}\n\tele.next = current.next\n\tcurrent.next = ele\n\tc.Size++\n}\n\nfunc (c *Chain) Delete(index uint) (bool, string) {\n\tok := true\n\tmsg := ""\n\tif index > c.Size {\n\t\tok = false\n\t\tmsg = "超过最大长度"\n\t\treturn ok, msg\n\t}\n\tvar count uint = 0\n\tcurrent := c.head\n\tif index == 0 {\n\t\toldHead := c.head\n\t\tc.head = current.next\n\t\tfor current.next != oldHead {\n\t\t\tcurrent = current.next\n\t\t}\n\t\tcurrent.next = c.head\n\t\tc.Size--\n\t\treturn ok, msg\n\t}\n\tfor count != index-1 {\n\t\tcurrent = current.next\n\t\tcount++\n\t}\n\tcurrent.next = current.next.next\n\tc.Size--\n\treturn ok, msg\n}\n\nfunc (c *Chain) Get(index uint) interface{} {\n\tif index >= c.Size {\n\t\treturn nil\n\t}\n\tvar count uint = 0\n\tcurrent := c.head\n\tfor count != index {\n\t\tcurrent = current.next\n\t\tcount++\n\t}\n\treturn current.data\n}\n\nfunc main() {\n\tchain := Chain{}\n\tchain.Push("第0个元素")\n\tchain.Push("第1个元素")\n\tchain.Push("第2个元素")\n\tfmt.Println(chain.Get((0)))\n\tfmt.Println(chain.Get((1)))\n\tfmt.Println(chain.Get((2)))\n\tchain.Insert(2, "第3个元素")\n\tfmt.Println(chain.Get((3)))\n\tfmt.Println(chain.Get((2)))\n\tchain.Delete(0)\n\tfmt.Println(chain.Get((0)))\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("p",[t._v("输出")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("第0个元素\n第1个元素\n第2个元素\n第2个元素\n第3个元素\n第1个元素\n")])])]),n("h2",{attrs:{id:"双向链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双向链表"}},[t._v("#")]),t._v(" 双向链表")]),t._v(" "),n("p",[t._v("每个节点包含一个指向前一个节点的引用和一个指向后一个节点的引用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  +---------+    +---------+    +---------+    +---------+\n  |   Prev  |    |   Prev  |    |   Prev  |    |   Prev  |\n  |   Data  |    |   Data  |    |   Data  |    |   Data  |\n  |   Next  +<--\x3e|   Next  +<--\x3e|   Next  +<--\x3e|   Null  |\n  +---------+    +---------+    +---------+    +---------+\n")])])]),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 双向链表+循环链表\npackage main\n\nimport (\n\t"fmt"\n)\n\ntype Chain struct {\n\tSize uint\n\thead *Ele\n}\ntype Ele struct {\n\tdata     interface{}\n\tnext     *Ele\n\tprevious *Ele\n}\n\nfunc (c *Chain) Push(data interface{}) {\n\tele := &Ele{\n\t\tdata: data,\n\t}\n\tif c.Size == 0 {\n\t\tc.head = ele\n\t\tele.next = c.head // 尾链接到头\n\t\tele.previous = c.head\n\t\tc.Size++\n\t\treturn\n\t}\n\tcurrent := c.head\n\tfor current.next != c.head {\n\t\tcurrent = current.next\n\t}\n\tele.previous = current\n\tele.next = c.head\n\tcurrent.next = ele\n\tc.head.previous = ele\n\tc.Size++\n}\n\nfunc (c *Chain) Get(index uint) interface{} {\n\tif index >= c.Size {\n\t\treturn nil\n\t}\n\tvar count uint = 0\n\tcurrent := c.head\n\t// 判断所取索引距离首尾远近\n\t// 若距离尾更近可以倒着往上推\n\tidx := c.Size - index\n\tif idx < index {\n\t\tfor count != idx {\n\t\t\tcurrent = current.previous\n\t\t\tcount++\n\t\t}\n\t\treturn current.data\n\t}\n\tfor count != index {\n\t\tcurrent = current.next\n\t\tcount++\n\t}\n\treturn current.data\n}\n\nfunc main() {\n\tchain := Chain{}\n\tchain.Push("第0个元素")\n\tchain.Push("第1个元素")\n\tchain.Push("第2个元素")\n\tchain.Push("第3个元素")\n\tchain.Push("第4个元素")\n\tfmt.Println(chain.Get((0)))\n\tfmt.Println(chain.Get((1)))\n\tfmt.Println(chain.Get((2)))\n\tfmt.Println(chain.Get((3)))\n\tfmt.Println(chain.Get((4)))\n\tfmt.Println(chain.Get((5)))\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("第0个元素\n第1个元素\n第2个元素\n第3个元素\n第4个元素\n<nil>  \n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);