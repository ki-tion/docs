(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{386:function(v,_,a){"use strict";a.r(_);var t=a(10),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"数据结构-散列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-散列表"}},[v._v("#")]),v._v(" "),_("center",[v._v("数据结构-散列表")])],1),v._v(" "),_("h2",{attrs:{id:"基本思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本思想"}},[v._v("#")]),v._v(" 基本思想")]),v._v(" "),_("p",[v._v("在记录的存储地址和它的关键码之间建立一个确定的对应关系，这样不经过比较一次读取就能得到所查元素。")]),v._v(" "),_("h2",{attrs:{id:"散列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[v._v("#")]),v._v(" 散列表")]),v._v(" "),_("p",[v._v("采用散列技术将记录存储在一块连续的存储空间(即数组)中，这块连续的存储空间称为散列表。")]),v._v(" "),_("h2",{attrs:{id:"散列函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#散列函数"}},[v._v("#")]),v._v(" 散列函数")]),v._v(" "),_("p",[v._v("散列函数是一个把查找表中的关键码映射为关键码存储地址的函数。设计散列函数一般应满足如下条件：")]),v._v(" "),_("ul",[_("li",[v._v("计算简单")]),v._v(" "),_("li",[v._v("散列地址分布均匀")])]),v._v(" "),_("h3",{attrs:{id:"设计方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计方法"}},[v._v("#")]),v._v(" 设计方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("直接定址法")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("散列函数是关键码的线性函数，即:"),_("code",[v._v("H(key) = a * key + b")]),v._v("(a,b为常数)")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("例如：若关键码集合为{10,30, 50, 70, 80, 90},散列函数为:"),_("code",[v._v("H(key) = key/10")]),v._v("，则散列表为:\n"),_("table",[_("thead",[_("td",[v._v("0")]),v._v(" "),_("td",[v._v("1")]),v._v(" "),_("td",[v._v("2")]),v._v(" "),_("td",[v._v("3")]),v._v(" "),_("td",[v._v("4")]),v._v(" "),_("td",[v._v("5")]),v._v(" "),_("td",[v._v("6")]),v._v(" "),_("td",[v._v("7")]),v._v(" "),_("td",[v._v("8")]),v._v(" "),_("td",[v._v("9")])]),v._v(" "),_("tbody",[_("tr",[_("td"),v._v(" "),_("td",[v._v("10")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("30")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("50")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("70")]),v._v(" "),_("td",[v._v("80")]),v._v(" "),_("td",[v._v("90")])])])])])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("适用于事先知道关键码，关键码集合不大且连续性较好")])])]),v._v(" "),_("li",[_("p",[v._v("数字分析法")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("根据关键码中各位数字的分布，选择合适的散列函数")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("适用于能预先知道关键码的分布情况")])])]),v._v(" "),_("li",[_("p",[v._v("平方取中法")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("对关键码进行平方后取中间几位作为散列地址")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("例如散列地址为2位，关键码为123456789，则其散列地址为"),_("code",[v._v("1234 * 1234 = 1522756")]),v._v("，取其中2位作为散列地址，即"),_("code",[v._v("27")])])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("适用于事先不知道关键码分布且关键码不能太大")])])]),v._v(" "),_("li",[_("p",[v._v("折叠法")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("将关键码从左到右分割成位数相等的几部分(最后一部分可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("例如，将关键码为"),_("code",[v._v("123456789")]),v._v("，每四位分割，散列地址为3位，则散列地址位921，计算如下")])])])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("    1234\n    5678\n+      9\n------------------\n    6921\n")])])]),_("ul",[_("li",[_("ul",[_("li",[v._v("适用于关键码位数很多且事先不知道关键码分布")])])]),v._v(" "),_("li",[_("p",[v._v("除留余数法")])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("散列函数为:"),_("code",[v._v("H(key) = key mod p")]),v._v("(p一般选取为一个略大于哈希表长度的"),_("strong",[v._v("质数")]),v._v(",以减少哈希冲突的发生)")])])]),v._v(" "),_("li",[_("ul",[_("li",[v._v("适用于事先不知道关键码的分布")])])])]),v._v(" "),_("h2",{attrs:{id:"散列地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#散列地址"}},[v._v("#")]),v._v(" 散列地址")]),v._v(" "),_("p",[v._v("由散列函数计算出来的地址。")]),v._v(" "),_("h2",{attrs:{id:"散列冲突"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#散列冲突"}},[v._v("#")]),v._v(" 散列冲突")]),v._v(" "),_("p",[v._v("对于不同的关键码可能得到同一散列地址，即关键码映射到同一个散列地址上。")]),v._v(" "),_("h2",{attrs:{id:"处理冲突的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#处理冲突的方法"}},[v._v("#")]),v._v(" 处理冲突的方法")]),v._v(" "),_("h3",{attrs:{id:"开放定址法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开放定址法"}},[v._v("#")]),v._v(" 开放定址法")]),v._v(" "),_("p",[v._v("若散列地址产生冲突，就去找下一个空地址，将记录存入。")]),v._v(" "),_("h4",{attrs:{id:"线性探测法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线性探测法"}},[v._v("#")]),v._v(" 线性探测法")]),v._v(" "),_("p",[v._v("当发生冲突时，将关键码加上一个增量，然后以该增量作为新的地址值，直到无冲突为止。")]),v._v(" "),_("p",[v._v("例如关键码集合为{47,7,29,11,16,92,22,8,3},关键码集合个数为9，选取一个大于9的质数11为散列表长度，散列函数选除留余数法。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("47%11=3，arr[3]=47\n7%11=7，arr[7]=7\n29%11=7，但arr[7]已被占用。(29+1)%11=8，arr[8]=29\n11%11=0，arr[0]=11\n16%11=5，arr[5]=16\n92%11=4，arr[4]=92\n22%11=0，但arr[0]已被占用。(22+1)%11=1，arr[1]=22\n8%11=8，但arr[8]已被占用。(8+1)%11=9，arr[9]=8\n3%11=3，但arr[3]已被占用。(3+1)%11=4，但arr[4]已被占用,(3+2)%11=5,arr[5]=3\n")])])]),_("h4",{attrs:{id:"二次线性探测法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二次线性探测法"}},[v._v("#")]),v._v(" 二次线性探测法")]),v._v(" "),_("p",[v._v("和线性探测法相同，只是冲突时，不是只加一个增量，而是分别试探将增量再平方后的值的正值和负值。")]),v._v(" "),_("h4",{attrs:{id:"随机探测法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#随机探测法"}},[v._v("#")]),v._v(" 随机探测法")]),v._v(" "),_("p",[v._v("当发生冲突时，随机选取一个值作为增量，直到无冲突为止。")]),v._v(" "),_("h3",{attrs:{id:"链地址法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链地址法"}},[v._v("#")]),v._v(" 链地址法")]),v._v(" "),_("p",[v._v("将所有关键码为同义词的记录存储在同一线性链表中。")])])}),[],!1,null,null,null);_.default=r.exports}}]);