(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{404:function(t,n,e){"use strict";e.r(n);var r=e(10),i=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"算法-赫夫曼编码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法-赫夫曼编码"}},[t._v("#")]),t._v(" "),n("center",[t._v("算法-赫夫曼编码")])],1),t._v(" "),n("p",[t._v("赫夫曼编码是一种无损数据压缩算法，它通过给每个字符分配一个比特串来实现数据压缩。赫夫曼编码算法是根据字符出现频率来分配比特串的，出现频率高的字符分配较短的比特串，出现频率低的字符分配较长比特串。")]),t._v(" "),n("h2",{attrs:{id:"工作原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),n("ul",[n("li",[t._v("统计所有字符出现的频率")]),t._v(" "),n("li",[t._v("根据字符出现频率对字符进行排序，出现频率高的字符排在前面，出现频率低的字符排在后面")]),t._v(" "),n("li",[t._v("构建一棵赫夫曼树，赫夫曼树的叶子节点对应所有字符，根节点对应一个虚拟节点")]),t._v(" "),n("li",[t._v("从根节点开始，沿着最短路径遍历树，直到到达叶子节点，这样就得到每个字符对应的比特串")]),t._v(" "),n("li",[t._v("使用比特串对原始数据进行编码，得到压缩数据")])]),t._v(" "),n("h2",{attrs:{id:"赫夫曼树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#赫夫曼树"}},[t._v("#")]),t._v(" 赫夫曼树")]),t._v(" "),n("p",[t._v("赫夫曼树是一种特殊的二叉树，用于无损数据压缩。赫夫曼树的特点是叶子节点上存储的是原始数据中的字符，叶子节点的权值是字符出现的频率。赫夫曼树的非叶子节点的权值是其子节点的权值之和。")]),t._v(" "),n("h3",{attrs:{id:"构造方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[t._v("#")]),t._v(" 构造方法")]),t._v(" "),n("ul",[n("li",[t._v("通过原始数据中每个字符出现的频率，给每个字符生成一颗二叉树。需要包含权重(频率),对应字符和前缀码")]),t._v(" "),n("li",[t._v("将出现频率最低的两个字符组合成一个新的节点，该节点的权值是两个字符权值之和")]),t._v(" "),n("li",[t._v("重复步骤2，直到所有字符都被组合成一个节点")])]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n\t"math/rand"\n\t"time"\n)\n\ntype HTree struct {\n\tParent     *HTree\n\tLeftChild  *HTree\n\tRightChild *HTree\n\tWeight     int // 权重(频率)\n\tCode       string // 前缀码,理论是二进制bit位，为了实现简单使用字符串代替\n\tChar       rune // 字符\n}\n\n// 最大权重\nconst MAX_WEIGHT = 100\n\n// 通过字符查找节点\nfunc (h *HTree) findNodeByChar(char rune) *HTree {\n\tif h.Char == char {\n\t\treturn h\n\t}\n\tif h.LeftChild != nil {\n\t\tnode := h.LeftChild.findNodeByChar(char)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t}\n\t}\n\tif h.RightChild != nil {\n\t\tnode := h.RightChild.findNodeByChar(char)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t}\n\t}\n\treturn nil\n}\n\n// 字符串转前缀码\nfunc (h *HTree) string2Codes(str string) string {\n\tcodes := ""\n\tfor i := 0; i < len(str); i++ {\n\t\tcodes += h.findNodeByChar(rune(str[i])).Code\n\t}\n\treturn codes\n}\n\n// 前缀码转字符串\nfunc (h *HTree) codes2String(codes string) string {\n\tstr := ""\n\tnode := h\n\tfor i := 0; i < len(codes); i++ {\n\t\tif string(codes[i]) == "0" {\n\t\t\tif node.LeftChild == nil {\n\t\t\t\tstr += string(node.Char)\n\t\t\t\tnode = h.LeftChild\n\t\t\t} else {\n\t\t\t\tnode = node.LeftChild\n\t\t\t}\n\t\t} else {\n\t\t\tif node.RightChild == nil {\n\t\t\t\tstr += string(node.Char)\n\t\t\t\tnode = h.RightChild\n\t\t\t} else {\n\t\t\t\tnode = node.RightChild\n\t\t\t}\n\t\t}\n\t}\n\tstr += string(node.Char)\n\treturn str\n}\n\n// 生成随机权重二叉树森林\nfunc createHTrees() []*HTree {\n\tarr := []*HTree{}\n    // 只生成A~z中间所有字符\n\tfor i := \'A\'; i < \'z\'; i++ {\n\t\tarr = append(arr, &HTree{\n\t\t\tChar:   i,\n\t\t\tWeight: rand.Intn(MAX_WEIGHT), // 随即权重\n\t\t})\n\t}\n\treturn arr\n}\n\n// 查找最小值下标\nfunc minValueIndex(arr []*HTree) int {\n\tidx := 0\n\tval := MAX_WEIGHT\n\tfor i, v := range arr {\n\t\tif v.Weight < val {\n\t\t\tidx = i\n\t\t\tval = v.Weight\n\t\t}\n\t}\n\treturn idx\n}\n\n// 通过下标删除元素\nfunc deleteByIndex(arr []*HTree, idx int) []*HTree {\n\tnewArr := []*HTree{}\n\tfor i := 0; i < len(arr); i++ {\n\t\tif i != idx {\n\t\t\tnewArr = append(newArr, arr[i])\n\t\t}\n\t}\n\treturn newArr\n}\n\n// 生成前缀码\n// 约定左节点是0 右节点是1\nfunc countCode(tree *HTree) {\n\tif tree.Parent == nil {\n\t\tif tree.LeftChild != nil {\n\t\t\ttree.LeftChild.Code = "0"\n\t\t\tcountCode(tree.LeftChild)\n\t\t}\n\t\tif tree.RightChild != nil {\n\t\t\ttree.RightChild.Code = "1"\n\t\t\tcountCode(tree.RightChild)\n\t\t}\n\t} else {\n\t\tif tree.LeftChild != nil {\n\t\t\ttree.LeftChild.Code = tree.Code + "0"\n\t\t\tcountCode(tree.LeftChild)\n\t\t}\n\t\tif tree.RightChild != nil {\n\t\t\ttree.RightChild.Code = tree.Code + "1"\n\t\t\tcountCode(tree.RightChild)\n\t\t}\n\t}\n}\n\n// 合并\nfunc mergeArr(arr []*HTree) *HTree {\n\tif len(arr) <= 0 {\n\t\treturn nil\n\t}\n\tif len(arr) <= 1 {\n\t\treturn arr[0]\n\t}\n    // 将出现频率最低的两个字符组合成一个新的节点，该节点的权值是两个字符权值之和\n\tfor len(arr) > 1 {\n\t\tminIdx1 := minValueIndex(arr)\n\t\tminVal1 := arr[minIdx1]\n\t\tarr = deleteByIndex(arr, minIdx1)\n\n\t\tminIdx2 := minValueIndex(arr)\n\t\tminVal2 := arr[minIdx2]\n\t\tarr = deleteByIndex(arr, minIdx2)\n\n\t\tparent := &HTree{\n\t\t\tWeight:     minVal1.Weight + minVal2.Weight,\n\t\t\tLeftChild:  minVal1,\n\t\t\tRightChild: minVal2,\n\t\t}\n\t\tminVal1.Parent = parent\n\t\tminVal2.Parent = parent\n\t\tarr = append(arr, parent)\n\n\t}\n\treturn arr[0]\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\thTree := mergeArr(createHTrees())\n\tcountCode(hTree)\n\n\tmsg := "iisfish"\n\tcodes := hTree.string2Codes(msg)\n\tfmt.Println(codes)\n\tfmt.Println(hTree.codes2String(codes))\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("111110111110111001001010111110111001111110\niisfish\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);