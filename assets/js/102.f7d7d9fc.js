(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{397:function(t,n,e){"use strict";e.r(n);var a=e(10),i=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构-图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-图"}},[t._v("#")]),t._v(" "),n("center",[t._v("数据结构-图")])],1),t._v(" "),n("h2",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("图是由顶点的"),n("em",[t._v("有穷非空")]),t._v("集合和顶点之间边的集合组成，通常表示为：G(V,E)\n其中 V 和 E 分别表示顶点集合与边的集合。边有向和无向之分。")]),t._v(" "),n("h2",{attrs:{id:"基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),n("ul",[n("li",[t._v("顶点：图的顶点可以简单理解为图中的节点，在图论中，顶点也被称为节点")]),t._v(" "),n("li",[t._v("边：边是连接两个顶点的线段")]),t._v(" "),n("li",[t._v("无向边：若顶点Vi和Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)表示")]),t._v(" "),n("li",[t._v("有向边：若顶点Vi和Vj之间的边有方向，则称这条边为有向边，用有序偶对<Vi,Vj>表示")]),t._v(" "),n("li",[t._v("无向图: 如果图的任意两个顶点之间的边都是无向边，则称该图为无向图")]),t._v(" "),n("li",[t._v("有向图: 如果图的任意两个顶点之间的边都是有向边，则称该图为有向图")]),t._v(" "),n("li",[t._v("无向完全图: 在无向图中。如果任意两个顶点之间都存在边，则称该图为无向完全图")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("含有n个顶点的无向完全图含有n(n-1)/2条边")])])]),t._v(" "),n("li",[t._v("有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("含有n个顶点的有向完全图含有n(n-1)条边")])])]),t._v(" "),n("li",[t._v("邻接(无向图)：如果顶点Vi和Vj之间存在边，则称Vi和Vj互为邻接点，同时称边(Vi,Vj)依附于Vi和Vj")]),t._v(" "),n("li",[t._v("邻接(有向图): 如果顶点Vi和Vj之间存在有向边<Vi,Vj>，则称Vi邻接到Vj，Vj邻接自Vi，同时称弧<Vi,Vj>依附于Vi和Vj")]),t._v(" "),n("li",[t._v("稀疏图: 指图中边的数目远小于顶点的数量的图，通常指边数占顶点数的 10% 以下")]),t._v(" "),n("li",[t._v("稠密图: 图中边的数量接近于或等于顶点的数量的平方，通常指边数占顶点数的 10% 以上")]),t._v(" "),n("li",[t._v("路径：路径是指从图中的一个顶点出发，到另一个顶点的经过的所有顶点序列")]),t._v(" "),n("li",[t._v("路径长度：")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("非带权图: 路径上经过的所有边的数目")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("带权图: 路径上经过的所有边的权值之和")])])]),t._v(" "),n("li",[t._v("简单路径：如果路径中任意两个顶点都不相同，则称该路径为简单路径")]),t._v(" "),n("li",[t._v("回路：如果路径中第一个顶点和最后一个顶点相同，则称该路径为回路")]),t._v(" "),n("li",[t._v("简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复的回路")]),t._v(" "),n("li",[t._v("简单图: 没有(自)环和重边的图")]),t._v(" "),n("li",[t._v("环：环是路径的一种，路径中如果出现了重复经过的顶点，那么路径就被称为环。")]),t._v(" "),n("li",[t._v("连通：如果从图中的一个顶点出发，能够到达图中的任意其他顶点，那么这两个顶点就属于同一个连通分量")]),t._v(" "),n("li",[t._v("连通图：如果一个图中，任意两个顶点之间都存在路径，那么这个图就被称为连通图")]),t._v(" "),n("li",[t._v("强连通图：在有向图中，如果任意两个顶点 v 和 w 之间都存在路径，那么这两个顶点都是强连通的")]),t._v(" "),n("li",[t._v("连通分量： 非联通图的"),n("em",[t._v("极大联通子图")])]),t._v(" "),n("li",[t._v("生成树：连通图中全部顶点的"),n("em",[t._v("极小连通子图")])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("解释1：保证子图联通的情况下，使得边的个数最小的图")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("解释2：包含"),n("em",[t._v("所有顶点")]),t._v("，使所有顶点都能通过边连接在一起，并且边的个数最小")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("解释3：以上前提是该图是一个连通图")])])]),t._v(" "),n("li",[t._v("生成森林：在非联通图中，由每个连通分量都可以得到一棵生成树，这些连通分量的生成树就组成了一个非联通图的"),n("em",[t._v("生成森林")])]),t._v(" "),n("li",[t._v("顶点的度(无向图)：顶点度数是和该顶点相连的边的数目")]),t._v(" "),n("li",[t._v("入度(有向图)：以顶点为终点的有向边的数目")]),t._v(" "),n("li",[t._v("出度(有向图)：以顶点为起点的有向边的数目")]),t._v(" "),n("li",[t._v("子图：如果一个图 G 的顶点和边是另一个图 G' 的顶点和边集的子集，那么 G' 被称为 G 的子图")]),t._v(" "),n("li",[t._v("权：指对边赋予有意义的数量值")]),t._v(" "),n("li",[t._v("网图：在图的边中，若含有权值，则称为网图")])]),t._v(" "),n("h2",{attrs:{id:"图的存储"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图的存储"}},[t._v("#")]),t._v(" 图的存储")]),t._v(" "),n("h3",{attrs:{id:"邻接矩阵"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#邻接矩阵"}},[t._v("#")]),t._v(" 邻接矩阵")]),t._v(" "),n("p",[t._v("用一个一维数组存储图中所有顶点，用一个二维数组存储图中各顶点之间的邻接关系，称为邻接矩阵")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport \"fmt\"\n\ntype MGraph struct {\n\tvertex    []rune   // 顶点数组\n\tarc       [][]uint // 邻接矩阵\n\tvertexNum uint     // 顶点数\n\tarcNum    uint     // 边数\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tvertexNum: 4,\n\t\tarcNum:    4,\n\t\tvertex:    []rune{'A', 'B', 'C', 'D'},\n\t\tarc: [][]uint{\n\t\t\t{0, 1, 0, 1},\n\t\t\t{1, 0, 1, 1},\n\t\t\t{0, 1, 0, 0},\n\t\t\t{1, 1, 0, 0},\n\t\t},\n\t}\n\tfmt.Println(g.arc[1]) // [1 0 1 1]\n}\n邻接矩阵存储稀疏图时比较浪费空间\n")])])]),n("h3",{attrs:{id:"邻接表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#邻接表"}},[t._v("#")]),t._v(" 邻接表")]),t._v(" "),n("p",[t._v("对于每个顶点Vi,将所有邻接于Vi的顶点连接成一个单链表，称之为顶点Vi的"),n("em",[t._v("边表")]),t._v("，所有边表的头指针和存储顶点信息的一维数组构成了顶点表")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport \"fmt\"\n\ntype EdgeNode struct {\n\tvertexIndex uint\n\tnext        *EdgeNode\n}\n\ntype VertexNode struct {\n\tname rune\n\tedge []*EdgeNode // 边表\n}\n\ntype ALGraph struct {\n\tvertex []*VertexNode // 顶点数组\n}\n\nfunc main() {\n\tg := &ALGraph{\n\t\tvertex: []*VertexNode{\n\t\t\t{name: 'A', edge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tvertexIndex: 1,\n\t\t\t\t\tnext: &EdgeNode{\n\t\t\t\t\t\tvertexIndex: 2,\n\t\t\t\t\t\tnext:        nil,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\t{name: 'B'},\n\t\t\t{name: 'c', edge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tvertexIndex: 3,\n\t\t\t\t\tnext:        nil,\n\t\t\t\t},\n\t\t\t}},\n\t\t\t{name: 'D', edge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tvertexIndex: 0,\n\t\t\t\t\tnext:        nil,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tfmt.Println(g)\n}\n\n\n")])])]),n("p",[t._v("邻接表存储稀疏图时比较浪费时间，比较适合有向图")]),t._v(" "),n("h3",{attrs:{id:"十字链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#十字链表"}},[t._v("#")]),t._v(" 十字链表")]),t._v(" "),n("p",[t._v("邻接表的边表存储的是该顶点的出度，再查找入度效率较低，将之反转一下，存储该点的入度则称之为逆邻接表。将邻接表和逆邻接表合二为一，称之为十字链表")]),t._v(" "),n("h3",{attrs:{id:"边集数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#边集数组"}},[t._v("#")]),t._v(" 边集数组")]),t._v(" "),n("p",[t._v("用一个一维数组存储图中所有顶点，用一个一维数组存储图中所有边，称为边集数组")]),t._v(" "),n("h2",{attrs:{id:"图的遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图的遍历"}},[t._v("#")]),t._v(" 图的遍历")]),t._v(" "),n("p",[t._v("图的遍历是在从图中某一顶点出发，对图中所有顶点访问一次且仅访问一次")]),t._v(" "),n("h3",{attrs:{id:"深度优先遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深度优先遍历"}},[t._v("#")]),t._v(" 深度优先遍历")]),t._v(" "),n("p",[t._v("图的深度优先遍历（Depth First Search，DFS）是从图中任意一个顶点 v 出发，依次访问 v 的所有未被访问过的邻接顶点，然后再从这些邻接顶点中选择一个未被访问过的顶点，重复上述过程，直到所有顶点都被访问过为止。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 基于 邻接矩阵\npackage main\n\nimport \"fmt\"\n\ntype VertexNode struct {\n\tname   rune\n\tvisted bool // 是否访问过\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode \n\tarc    [][]uint     \n\tarcNum uint          \n}\n\nfunc (m *MGraph) initMGraphVertexVisted() {\n\tfor i := 0; i < len(m.vertex); i++ {\n\t\tm.vertex[i].visted = false\n\t}\n}\nfunc (m *MGraph) foreachVertex(v *VertexNode, vIndex int) {\n\tif v.visted {\n\t\treturn\n\t}\n\tfmt.Println(\"visted node:\" + string(v.name))\n\tv.visted = true\n\tfor i := 0; i < len(m.arc[vIndex]); i++ {\n\t\tif m.arc[vIndex][i] != 0 {\n\t\t\tm.foreachVertex(m.vertex[i], i)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tarcNum: 9,\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname:   '1',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '2',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '3',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '4',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '5',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '6',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '7',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '8',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t},\n\t\tarc: [][]uint{\n\t\t\t{0, 1, 1, 0, 0, 0, 0, 0},\n\t\t\t{1, 0, 0, 1, 1, 0, 0, 0},\n\t\t\t{1, 0, 0, 0, 0, 1, 1, 0},\n\t\t\t{0, 1, 0, 0, 1, 0, 0, 1},\n\t\t\t{0, 1, 0, 1, 0, 0, 0, 0},\n\t\t\t{0, 0, 1, 0, 0, 0, 1, 0},\n\t\t\t{0, 0, 1, 0, 0, 1, 0, 0},\n\t\t\t{0, 0, 0, 1, 0, 0, 0, 0},\n\t\t},\n\t}\n\tg.foreachVertex(g.vertex[0], 0)\n\tg.initMGraphVertexVisted()\n}\n\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("visted node:1\nvisted node:2\nvisted node:4\nvisted node:5\nvisted node:8\nvisted node:3\nvisted node:6\nvisted node:7\n")])])]),n("h3",{attrs:{id:"广度优先遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#广度优先遍历"}},[t._v("#")]),t._v(" 广度优先遍历")]),t._v(" "),n("p",[t._v("图的广度优先遍历（Breadth First Search，BFS）是从图中任意一个顶点 v 出发，将 v 加入队列 Q，然后依次从队列中取出顶点，访问该顶点的所有未被访问过的邻接顶点，将这些邻接顶点加入队列 Q，重复上述过程，直到队列为空为止。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 基于 邻接矩阵\npackage main\n\nimport \"fmt\"\n\ntype VertexNode struct {\n\tname   rune\n\tvisted bool\n}\n\ntype PoolNode struct {\n\tnode  *VertexNode\n\tindex int\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode // 顶点数组\n\tarc    [][]uint      // 邻接矩阵\n\tarcNum uint          // 边数\n}\n\nfunc (m *MGraph) initMGraphVertexVisted() {\n\tfor i := 0; i < len(m.vertex); i++ {\n\t\tm.vertex[i].visted = false\n\t}\n}\nfunc (m *MGraph) foreachVertex(v *VertexNode, vIndex int) {\n\tnextPool := []*PoolNode{\n\t\t{\n\t\t\tnode:  v,\n\t\t\tindex: vIndex,\n\t\t},\n\t}\n\n\tfor len(nextPool) > 0 {\n\t\tcurrent := nextPool[0]\n\t\tnextPool = nextPool[1:]\n\t\tif current.node.visted {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(\"visted node:\" + string(current.node.name))\n\t\tcurrent.node.visted = true\n\n\t\tfor i := 0; i < len(m.arc[current.index]); i++ {\n\t\t\tif m.arc[current.index][i] != 0 {\n\t\t\t\tnextPool = append(nextPool, &PoolNode{\n\t\t\t\t\tnode:  m.vertex[i],\n\t\t\t\t\tindex: i,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tarcNum: 9,\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname:   '1',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '2',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '3',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '4',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '5',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '6',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '7',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   '8',\n\t\t\t\tvisted: false,\n\t\t\t},\n\t\t},\n\t\tarc: [][]uint{\n\t\t\t{0, 1, 1, 0, 0, 0, 0, 0},\n\t\t\t{1, 0, 0, 1, 1, 0, 0, 0},\n\t\t\t{1, 0, 0, 0, 0, 1, 1, 0},\n\t\t\t{0, 1, 0, 0, 1, 0, 0, 1},\n\t\t\t{0, 1, 0, 1, 0, 0, 0, 0},\n\t\t\t{0, 0, 1, 0, 0, 0, 1, 0},\n\t\t\t{0, 0, 1, 0, 0, 1, 0, 0},\n\t\t\t{0, 0, 0, 1, 0, 0, 0, 0},\n\t\t},\n\t}\n\tg.foreachVertex(g.vertex[0], 0)\n\tg.initMGraphVertexVisted()\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("visted node:1\nvisted node:2\nvisted node:3\nvisted node:4\nvisted node:5\nvisted node:6\nvisted node:7\nvisted node:8\n")])])]),n("h2",{attrs:{id:"最小生成树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树"}},[t._v("#")]),t._v(" 最小生成树")]),t._v(" "),n("p",[t._v("prim算法是对点操作，kruskal算法是对边操作，都是贪心算法。")]),t._v(" "),n("h3",{attrs:{id:"mst性质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mst性质"}},[t._v("#")]),t._v(" MST性质")]),t._v(" "),n("p",[t._v("在任何一个连通网络中，如果有一棵最小生成树，那么这棵树中一定包含所有权值最小的边")]),t._v(" "),n("h3",{attrs:{id:"prim算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prim算法"}},[t._v("#")]),t._v(" prim算法")]),t._v(" "),n("p",[t._v("基本思想是从图中任意一个顶点开始，不断地加入与该顶点相连的权值最小的边，直到所有顶点都被连接起来。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype VertexNode struct {\n\tname rune\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode\n\tarc    [][]uint\n\tarcNum uint\n}\n\nfunc include(list []int, ele int) bool {\n\tlength := len(list)\n\tif length == 0 {\n\t\treturn false\n\t}\n\tfor i := 0; i < length; i++ {\n\t\tif list[i] == ele {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (g *MGraph) minimumSpanningTree(startIndex int) [][]int {\n\tu := []int{startIndex}\n\tvertexNums := len(g.vertex)\n\tsides := [][]int{}\n\tfor i := 0; i < vertexNums; i++ {\n\t\tside := []int{}\n\t\tfor j := 0; j < vertexNums; j++ {\n\t\t\tside = append(side, 0)\n\t\t}\n\t\tsides = append(sides, side)\n\t}\n\n\tfor len(u) < vertexNums {\n\t\tv := []int{}\n\t\tfor i := 0; i < vertexNums; i++ {\n\t\t\tif !include(u, i) {\n\t\t\t\tv = append(v, i)\n\t\t\t}\n\t\t}\n\t\tminValue := math.MaxInt\n\t\tminPosi := []int{0, 0}\n\t\tfor i := 0; i < len(u); i++ {\n\t\t\tfor j := 0; j < len(v); j++ {\n\t\t\t\trow := u[i]\n\t\t\t\tcolumn := v[j]\n\t\t\t\tif g.arc[row][column] > 0 && g.arc[row][column] < uint(minValue) {\n\t\t\t\t\tminValue = int(g.arc[row][column])\n\t\t\t\t\tminPosi = []int{row, column}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsides[minPosi[0]][minPosi[1]] = int(minValue)\n\t\tu = append(u, minPosi[1])\n\t}\n\treturn sides\n\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tarcNum: 9,\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname: 'A',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'B',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'C',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'D',\n\t\t\t},\n\t\t},\n\t\tarc: [][]uint{\n\t\t\t//\t  A   B   C  D\n\t\t\t/*A*/{0,  4,  9, 21},\n\t\t\t/*B*/{4,  0,  8, 17},\n\t\t\t/*C*/{9,  8,  0, 16},\n\t\t\t/*D*/{21, 17, 16, 0},\n\t\t},\n\t}\n\tres := g.minimumSpanningTree(0)\n\tfor i := 0; i < len(res); i++ {\n\t\tfmt.Println(res[i])\n\t}\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[0 4 0 0]\n[0 0 8 0]\n[0 0 0 16]\n[0 0 0 0]\n")])])]),n("h3",{attrs:{id:"kruskal算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kruskal算法"}},[t._v("#")]),t._v(" kruskal算法")]),t._v(" "),n("p",[t._v("基本思想是先将边(根据权重)进行排序，然后每次取出最小的边，如果它和当前最小生成树不构成回路(环)就将其加入最小生成树，反之删除。直到所有的边都处理完毕。")]),t._v(" "),n("p",[t._v("具体来说")]),t._v(" "),n("ul",[n("li",[t._v("首先将图中的所有边按照权重从小到大排序")]),t._v(" "),n("li",[t._v("初始化树，将图中的所有顶点看做一个个树，默认都是根节点")]),t._v(" "),n("li",[t._v("遍历所有边，如果边的两个顶点的根节点不同(没有相同的根节点说明没有环)，则将此边加入到最小生成树中，并将两个树合并")]),t._v(" "),n("li",[t._v("重复以上步骤，直到所有顶点都加入到最小生成树中或者边的数量达到顶点数-1，最小生成树构造完毕")])]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype VertexNode struct {\n\tname rune\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode\n\tarc    [][]int\n}\n\ntype Side struct {\n\tweight int\n\tedge   [2]int\n}\n\nfunc (g *MGraph) minimumSpanningTree() [][]int {\n\t// 从矩阵中取出边\n\tsides := []*Side{}\n\tfor i := 0; i < len(g.arc); i++ {\n\t\tfor j := 0; j < len(g.arc[i]); j++ {\n\t\t\tif g.arc[i][j] > 0 {\n\t\t\t\tsides = append(sides, &Side{\n\t\t\t\t\tweight: g.arc[i][j],\n\t\t\t\t\tedge:   [2]int{i, j},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\t// 对边进行排序\n\tsort.Slice(sides, func(i, j int) bool {\n\t\treturn sides[i].weight < sides[j].weight\n\t})\n\n\tvertexNums := len(g.vertex)\n\t// 根据每个顶点生成一颗树，下标表示第几课，值表示其父节点，默认都是根节点，用-1表示\n\ttree := []int{}\n\tfor i := 0; i < vertexNums; i++ {\n\t\ttree = append(tree, -1)\n\t}\n\n\t// 选中的边\n\tselected := []*Side{}\n\tfor len(sides) > 0 && len(selected) < vertexNums-1 {\n\t\tside := sides[0]\n\t\tsides = sides[1:]\n\n\t\t// 第一个节点的根节点\n\t\tfromRoot := side.edge[0]\n\t\tfor tree[fromRoot] != -1 {\n\t\t\tfromRoot = tree[fromRoot]\n\t\t}\n\n\t\t// 第二个节点的根节点\n\t\ttoRoot := side.edge[1]\n\t\tfor tree[toRoot] != -1 {\n\t\t\ttoRoot = tree[toRoot]\n\t\t}\n\n\t\t// 判断是否有环的条件是两个节点的根是否相同\n\t\tif fromRoot != toRoot {\n\t\t\ttree[toRoot] = fromRoot\n\t\t\tselected = append(selected, side)\n\t\t}\n\n\t}\n\n\ttable := [][]int{}\n\tfor i := 0; i < vertexNums; i++ {\n\t\tside := []int{}\n\t\tfor j := 0; j < vertexNums; j++ {\n\t\t\tside = append(side, 0)\n\t\t}\n\t\ttable = append(table, side)\n\t}\n\n\tfor i := 0; i < len(selected); i++ {\n\t\titem := selected[i]\n\t\ttable[item.edge[0]][item.edge[1]] = item.weight\n\t}\n\n\treturn table\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname: 'A',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'B',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'C',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'D',\n\t\t\t},\n\t\t},\n\t\tarc: [][]int{\n\t\t\t{0, 4, 9, 21},\n\t\t\t{4, 0, 8, 17},\n\t\t\t{9, 8, 0, 16},\n\t\t\t{21, 17, 16, 0},\n\t\t},\n\t}\n\tres := g.minimumSpanningTree()\n\tfor i := 0; i < len(res); i++ {\n\t\tfmt.Println(res[i])\n\t}\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[0 4 0 0]\n[0 0 8 0]\n[0 0 0 16]\n[0 0 0 0]\n")])])]),n("h2",{attrs:{id:"最短路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最短路径"}},[t._v("#")]),t._v(" 最短路径")]),t._v(" "),n("p",[t._v("在非网图中，最短路径是指两个顶点之间经历的边数最少的路径。")]),t._v(" "),n("p",[t._v("在网图中，最短路径是指两个顶点之间所经过的边上权值之和最少的路径。")]),t._v(" "),n("h3",{attrs:{id:"迪杰斯特拉算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#迪杰斯特拉算法"}},[t._v("#")]),t._v(" 迪杰斯特拉算法")]),t._v(" "),n("p",[t._v("迪杰斯特拉算法（Dijkstra's algorithm）是典型最短路径算法，用于计算一个节点到其他节点的最短路径。")]),t._v(" "),n("p",[t._v("基本思想是将所有顶点分别为两个集合U，V，集合U存放已处理的顶点，集合V存放未处理的顶点，然后不断从V中寻找距离起始点最近的顶点，将其放入U中，若有到个点更近的路劲则更新新的路径。重复该操作，直到遍历完所有顶点。有点类似prim算法。")]),t._v(" "),n("p",[t._v("具体来说：")]),t._v(" "),n("ul",[n("li",[t._v("定义两个集合U(存放已处理顶点)和V(存放未处理顶点),初始时，U只包含起点；定义一个数组dist记录起点到各个顶点的距离；定义一个数组path记录起点到各个顶点之间的路径。")]),t._v(" "),n("li",[t._v("初始化dist数组，长度为顶点数。查找起点到各个顶点的距离，没有边的记作+∞")]),t._v(" "),n("li",[t._v("初始化path数组，长度为顶点数，如果对应的dist有权值，值为起点下标，反之记作-1")]),t._v(" "),n("li",[t._v("从V集合中找到距离U集合最短的顶点k，加入U集合。如果当前顶点到其余个点的距离+以往距离之和(k的权重+dist[k的下标])小于dist表中记录到个点的距离(dist[i])，说明有更短路径，更新dist[i]为k的权重+dist[k的下标]，path[i]为k的下标。重复直到遍历完所有顶点。")]),t._v(" "),n("li",[t._v("dist[i]即表示起点到第i个顶点的最短距离")]),t._v(" "),n("li",[t._v("查找path[i]并记录，若path[i]不为起点下标，i=path[i],重复步骤，直到起点下标。将记录的路径翻转既是起点到下表为i的顶点的最短路径。")])]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype VertexNode struct {\n\tname rune\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode\n\tarc    [][]int\n}\n\nfunc include(list []int, ele int) bool {\n\tlength := len(list)\n\tif length == 0 {\n\t\treturn false\n\t}\n\tfor i := 0; i < length; i++ {\n\t\tif list[i] == ele {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * @param startIndex 起点顶点下标\n * @param endIndex 终点顶点下标\n * @returns 距离 路径\n */\nfunc (g *MGraph) dijkstra(startIndex int, endIndex int) (int, []int) {\n\t// 已处理顶点\n\tu := []int{startIndex}\n\n\tvertexNums := len(g.vertex)\n\n\t// 距离\n\tdist := g.arc[startIndex]\n\n\t// 路径\n\tpath := []int{}\n\tfor i := 0; i < vertexNums; i++ {\n\t\tif dist[i] < math.MaxInt {\n\t\t\tpath = append(path, startIndex)\n\t\t} else {\n\t\t\tpath = append(path, -1)\n\t\t}\n\t}\n\n\tfor len(u) < vertexNums {\n\t\t// 未处理顶点\n\t\tv := []int{}\n\t\tfor i := 0; i < vertexNums; i++ {\n\t\t\tif !include(u, i) {\n\t\t\t\tv = append(v, i)\n\t\t\t}\n\t\t}\n\t\tminValue := math.MaxInt\n\t\tminPosi := []int{0, 0}\n\t\tfor i := 0; i < len(u); i++ {\n\t\t\tfor j := 0; j < len(v); j++ {\n\t\t\t\trow := u[i]\n\t\t\t\tcolumn := v[j]\n\t\t\t\tif g.arc[row][column] > 0 && g.arc[row][column] < minValue {\n\t\t\t\t\tminValue = int(g.arc[row][column])\n\t\t\t\t\tminPosi = []int{row, column}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tu = append(u, minPosi[1])\n\n\t\tvalIndex := minPosi[1]\n\t\tval := g.arc[valIndex]\n\t\tfor i := 0; i < len(val); i++ {\n\t\t\t// 当前权重+以前权重之和小于dist,说明有更短路径，更新dist和path\n\t\t\tif val[i] > 0 && val[i] < math.MaxInt {\n\t\t\t\ttotal := val[i] + dist[valIndex]\n\t\t\t\tif total < dist[i] {\n\t\t\t\t\tdist[i] = total\n\t\t\t\t\tpath[i] = valIndex\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdistance := dist[endIndex]\n\tcurrent := endIndex\n\tindexPath := []int{}\n\tfor current != startIndex {\n\t\tindexPath = append(indexPath, current)\n\t\tcurrent = path[current]\n\t}\n\tindexPath = append(indexPath, startIndex)\n\t// 翻转切片\n\tfor i, j := 0, len(indexPath)-1; i < j; i, j = i+1, j-1 {\n\t\tindexPath[i], indexPath[j] = indexPath[j], indexPath[i]\n\t}\n\treturn distance, indexPath\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname: 'A',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'B',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'C',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'D',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'E',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'F',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'G',\n\t\t\t},\n\t\t},\n\t\tarc: [][]int{\n\t\t\t{0, 4, 6, 6, math.MaxInt, math.MaxInt, math.MaxInt},\n\t\t\t{math.MaxInt, 0, 1, math.MaxInt, 7, math.MaxInt, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, 0, math.MaxInt, 6, 4, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, 2, 0, math.MaxInt, 5, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 0, math.MaxInt, 6},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 1, 0, 8},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 0},\n\t\t},\n\t}\n\t// 计算第0个顶点到第6个顶点的最短距离和路径\n\tdistance, indexPath := g.dijkstra(0, 6)\n\tfmt.Println(distance)\n\tfmt.Println(indexPath)\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("16\n[0 1 2 5 4 6]\n")])])]),n("h3",{attrs:{id:"弗洛伊德算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#弗洛伊德算法"}},[t._v("#")]),t._v(" 弗洛伊德算法")]),t._v(" "),n("p",[t._v("Floyd算法是一种在带权有向图中找到任意两点之间最短路径的算法。该算法是动态规划算法的一种，时间复杂度为 O(V^3)，其中 V 是顶点的数量。")]),t._v(" "),n("p",[t._v("Floyd算法的思路是，从每个顶点出发，逐个考虑经过其他顶点的中转，更新从该顶点到其他顶点的最短路径。")]),t._v(" "),n("p",[t._v("具体来说:")]),t._v(" "),n("ul",[n("li",[t._v("初始化：对于任意两个顶点 u 和 v，如果 u 和 v 之间没有边，则设 d(u, v) = ∞。否则，设 d(u, v) 为 u 和 v 之间边的权值。")]),t._v(" "),n("li",[t._v("循环：对于每个顶点 k，对于任意两个顶点 u 和 v，如果 d(u, v) > d(u, k) + d(k, v)，则更新 d(u, v) = d(u, k) + d(k, v)。")]),t._v(" "),n("li",[t._v("结束：重复第 2 步，直到 d(u, v) 不再更新为止。")])]),t._v(" "),n("p",[n("strong",[t._v("公式（k表示当前加入的顶点，ij表示邻接矩阵坐标）：")]),t._v("\ndist"),n("sub",[t._v("k")]),t._v("[i][j] = min(dist"),n("sub",[t._v("k-1")]),t._v("[i][j], dist"),n("sub",[t._v("k-1")]),t._v("[i][k] + dist"),n("sub",[t._v("k-1")]),t._v("[k][j])")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype VertexNode struct {\n\tname rune\n}\n\ntype MGraph struct {\n\tvertex []*VertexNode\n\tarc    [][]int\n}\n\ntype FloydEle struct {\n\tdistance int\n\tpath     []int\n}\n\nfunc (g *MGraph) floyd() [][]*FloydEle {\n\tfloyTable := [][]*FloydEle{}\n\tvertexNums := len(g.vertex)\n\tfor i := 0; i < vertexNums; i++ {\n\t\trow := []*FloydEle{}\n\t\tfor j := 0; j < vertexNums; j++ {\n\t\t\tele := &FloydEle{\n\t\t\t\tdistance: g.arc[i][j],\n\t\t\t\tpath:     []int{},\n\t\t\t}\n\t\t\tif g.arc[i][j] > 0 && g.arc[i][j] < math.MaxInt {\n\t\t\t\tele.path = append(ele.path, i, j)\n\t\t\t}\n\t\t\trow = append(row, ele)\n\t\t}\n\t\tfloyTable = append(floyTable, row)\n\t}\n\tfor k := 0; k < vertexNums; k++ {\n\t\tfor i := 0; i < vertexNums; i++ {\n\t\t\tfor j := 0; j < vertexNums; j++ {\n\t\t\t\tif floyTable[i][k].distance < math.MaxInt && floyTable[k][j].distance < math.MaxInt && floyTable[i][k].distance+floyTable[k][j].distance < floyTable[i][j].distance {\n\t\t\t\t\tfloyTable[i][j].distance = floyTable[i][k].distance + floyTable[k][j].distance\n\t\t\t\t\tpath := []int{}\n\t\t\t\t\tpath = append(path, floyTable[i][k].path...)\n\t\t\t\t\tpath = append(path, floyTable[k][j].path[1:]...)\n\t\t\t\t\tfloyTable[i][j].path = path\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn floyTable\n}\n\nfunc main() {\n\tg := &MGraph{\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname: 'A',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'B',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'C',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'D',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'E',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'F',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'G',\n\t\t\t},\n\t\t},\n\t\tarc: [][]int{\n\t\t\t{0, 4, 6, 6, math.MaxInt, math.MaxInt, math.MaxInt},\n\t\t\t{math.MaxInt, 0, 1, math.MaxInt, 7, math.MaxInt, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, 0, math.MaxInt, 6, 4, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, 2, 0, math.MaxInt, 5, math.MaxInt},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 0, math.MaxInt, 6},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 1, 0, 8},\n\t\t\t{math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, math.MaxInt, 0},\n\t\t},\n\t}\n\tfmt.Println(g.floyd()[0][6])\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("&{16 [0 1 2 5 4 6]}\n")])])]),n("h2",{attrs:{id:"aov网"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aov网"}},[t._v("#")]),t._v(" AOV网")]),t._v(" "),n("p",[t._v("在一个表示工程(不能有环)的有向图中，顶点表示活动，弧表示活动间的优先关系，这样的有向图称为AOV网（Activity On Vertex Network）。")]),t._v(" "),n("h3",{attrs:{id:"拓扑序列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#拓扑序列"}},[t._v("#")]),t._v(" 拓扑序列")]),t._v(" "),n("p",[t._v("设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1,v2,…,vn称为一个拓扑序列，当且仅当满足条件：从顶点Vi到Vj存在路径，则在顶点序列中Vi在Vj之前。")]),t._v(" "),n("h3",{attrs:{id:"拓扑排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#拓扑排序"}},[t._v("#")]),t._v(" 拓扑排序")]),t._v(" "),n("p",[t._v("对一个有向图构造拓扑序列的过程称之为拓扑排序。")]),t._v(" "),n("p",[t._v("拓扑排序算法可描述如下：")]),t._v(" "),n("ul",[n("li",[t._v("求一个入度为0的顶点，并输出之。")]),t._v(" "),n("li",[t._v("从图中删除该顶点及所有以它为起点的有向边。")]),t._v(" "),n("li",[t._v("重复执行第一步和第二步，直到当前的顶点数为0或者当前图中不存在入度为0的顶点为止。")])]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 使用邻接表存储\npackage main\n\nimport \"fmt\"\n\ntype VertexNode struct {\n\tname rune\n\tin   uint // 入度个数\n\tedge []uint\n}\n\ntype ALGraph struct {\n\tvertex []*VertexNode\n}\n\n// 拓扑排序\nfunc (g *ALGraph) sort() []uint {\n\tcount := 0\n\tstack := []uint{}\n\tres := []uint{}\n\tfor i := 0; i < len(g.vertex); i++ {\n\t\tif g.vertex[i].in == 0 {\n\t\t\ttmp := []uint{}\n\t\t\ttmp = append(tmp, uint(i))\n\t\t\ttmp = append(tmp, stack...)\n\t\t\tstack = tmp\n\t\t}\n\t}\n\tfor len(stack) > 0 {\n\t\tcount++\n\t\tindex := stack[0]\n\t\titem := g.vertex[index]\n\t\tres = append(res, index)\n\t\tstack = stack[1:]\n\t\tlength := len(item.edge)\n\t\tif length > 0 {\n\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\tg.vertex[item.edge[i]].in--\n\t\t\t\tif g.vertex[item.edge[i]].in == 0 {\n\t\t\t\t\ttmp := []uint{}\n\t\t\t\t\ttmp = append(tmp, uint(item.edge[i]))\n\t\t\t\t\ttmp = append(tmp, stack...)\n\t\t\t\t\tstack = tmp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif count != len(g.vertex) {\n\t\tfmt.Println(\"存在环\")\n\t}\n\treturn res\n}\n\nfunc main() {\n\tg := &ALGraph{\n\t\tvertex: []*VertexNode{\n\t\t\t{\n\t\t\t\tname: 'A',\n\t\t\t\tin:   3,\n\t\t\t\tedge: []uint{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'B',\n\t\t\t\tin:   0,\n\t\t\t\tedge: []uint{0, 3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'C',\n\t\t\t\tin:   1,\n\t\t\t\tedge: []uint{0, 3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'D',\n\t\t\t\tin:   3,\n\t\t\t\tedge: []uint{0, 5},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'E',\n\t\t\t\tin:   0,\n\t\t\t\tedge: []uint{2, 3, 5},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'F',\n\t\t\t\tin:   2,\n\t\t\t\tedge: []uint{},\n\t\t\t},\n\t\t},\n\t}\n\n\tfmt.Println(g.sort())\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[4 2 1 3 5 0]\n")])])]),n("h2",{attrs:{id:"aoe网"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aoe网"}},[t._v("#")]),t._v(" AOE网")]),t._v(" "),n("p",[t._v("在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动持续的时间，这样的有向图称为AOE网。AOE网中没有入边的顶点称为始点（源点），没有出边的顶点称为终点（汇点）。")]),t._v(" "),n("p",[t._v("简而言之AOV网是无权的有向图，AOE网是有权的有向图。")]),t._v(" "),n("h3",{attrs:{id:"性质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性质"}},[t._v("#")]),t._v(" 性质")]),t._v(" "),n("ul",[n("li",[t._v("只有在某顶点所代表的时间发生后，从该点出发的各活动才能开始。")]),t._v(" "),n("li",[t._v("只有在进入某顶点的活动都结束，该顶点所代表的时间才能发生。")])]),t._v(" "),n("h3",{attrs:{id:"相关术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相关术语"}},[t._v("#")]),t._v(" 相关术语")]),t._v(" "),n("ul",[n("li",[t._v("事件最早发生时间ve[k]：")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("从始点到顶点V"),n("sub",[t._v("k")]),t._v("的最长路径")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("决定所有从顶点V"),n("sub",[t._v("k")]),t._v("发出的活动能够开工的最早时间、")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("ve[k] = max{ve[i] + len<v"),n("sub",[t._v("i")]),t._v(", v"),n("sub",[t._v("k")]),t._v(">} // 起点的ve值初始化为0")])])]),t._v(" "),n("li",[t._v("事件最迟发生时间vl[k]：")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("通俗来说就是在不影响其他活动的情况下，最迟开工的时间")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("按逆拓扑排序，最后一个节点的最迟发生时间就是整个工程的最早完成时间。用节点的最迟发生时间-边的长度既是该边开始顶点(事件)的最迟发生时间。")])])]),t._v(" "),n("li",[t._v("活动最早发生时间ee[k]：")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("活动最早可以开始的时间")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("逻辑上就是事件最早发生时间")])])]),t._v(" "),n("li",[t._v("活动最迟生时间el[k]：")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("活动最生可以开始的时间")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("事件的最迟发生时间减去该边长度就是活动最迟生时间")])])])]),t._v(" "),n("h3",{attrs:{id:"关键路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关键路径"}},[t._v("#")]),t._v(" 关键路径")]),t._v(" "),n("p",[t._v("在AOE网中，从始点到终点具有最大路径长度（即耗费时间之和最多）的若干条路径，称为关键路径(关键路可能不止一条)。")]),t._v(" "),n("p",[t._v("关键路径上的活动称为关键活动。通俗来说就是不能耽搁的活动(没有耽搁余地)，耽搁了就会影响整个工程。反过来说关键活动组成的路径就是关键路径。关键路径判断方法为：活动最早发生时间ee == 活动最早迟生时间el")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("package main\n\nimport (\n\t\"fmt\"\n)\n\ntype EdgeNode struct {\n\tto     uint // 指向的顶点\n\tweight uint // 边的权重\n}\n\ntype VertexNode struct {\n\tname rune\n\tin   uint        // 入度个数\n\tedge []*EdgeNode // 用切片替代链表方便编程\n}\n\ntype ALGraph struct {\n\tvertex        []*VertexNode // 顶点\n\tsequence      []uint        // 拓扑序列\n\tflag          bool          // false表示有环\n\tve            []uint        // 事件最早发生时间\n\tvl            []uint        // 事件最迟发生时间\n\tee            []uint        // 活动最早发生时间\n\tel            []uint        // 活动最迟发生时间\n\tkeyActivities [][2]uint     // 关键路径(el[k] == ee[k])\n}\n\n// 拓扑排序\nfunc (g *ALGraph) sort() []uint {\n\tcount := 0\n\tstack := []uint{}\n\tres := []uint{}\n\tfor i := 0; i < len(g.vertex); i++ {\n\t\tif g.vertex[i].in == 0 {\n\t\t\ttmp := []uint{}\n\t\t\ttmp = append(tmp, uint(i))\n\t\t\ttmp = append(tmp, stack...)\n\t\t\tstack = tmp\n\t\t}\n\t}\n\tfor len(stack) > 0 {\n\t\tcount++\n\t\tindex := stack[0]\n\t\titem := g.vertex[index]\n\t\tres = append(res, index)\n\t\tstack = stack[1:]\n\t\tlength := len(item.edge)\n\t\tif length > 0 {\n\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\tg.vertex[item.edge[i].to].in--\n\t\t\t\tif g.vertex[item.edge[i].to].in == 0 {\n\t\t\t\t\ttmp := []uint{}\n\t\t\t\t\ttmp = append(tmp, uint(item.edge[i].to))\n\t\t\t\t\ttmp = append(tmp, stack...)\n\t\t\t\t\tstack = tmp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tg.flag = count == len(g.vertex)\n\treturn res\n}\n\n// 计算事件的最早发生时间\nfunc (g *ALGraph) setVe() {\n\tlength := len(g.vertex)\n\tg.ve = make([]uint, length)\n\tfor i := 0; i < length; i++ {\n\t\tg.ve[i] = 0\n\t}\n\tfor i := 0; i < len(g.sequence); i++ {\n\t\tindex := g.sequence[i]\n\t\titem := g.vertex[index]\n\t\tfor j := 0; j < len(item.edge); j++ {\n\t\t\tedge := item.edge[j]\n\t\t\tif g.ve[edge.to] < g.ve[index]+edge.weight {\n\t\t\t\tg.ve[edge.to] = g.ve[index] + edge.weight\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 计算事件的最迟发生时间\nfunc (g *ALGraph) setVl() {\n\tlength := len(g.sequence)\n\tg.vl = make([]uint, length)\n\tmax := g.ve[length-1]\n\tfor i := 0; i < length; i++ {\n\t\tg.vl[i] = max\n\t}\n\tfor i := length - 1; i >= 0; i-- {\n\t\tindex := g.sequence[i]\n\t\titem := g.vertex[index]\n\t\tfor j := 0; j < len(item.edge); j++ {\n\t\t\tedge := item.edge[j]\n\n\t\t\tif g.vl[index] > g.vl[edge.to]-edge.weight {\n\t\t\t\tg.vl[index] = g.vl[edge.to] - edge.weight\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 计算活动最早发生时间\nfunc (g *ALGraph) setEe() {\n\tg.ee = g.ve\n}\n\n// 计算活动最迟发生时间\nfunc (g *ALGraph) setEl() {\n\tlength := len(g.sequence)\n\tg.el = make([]uint, length)\n\tg.keyActivities = [][2]uint{}\n\tfor i := 0; i < length; i++ {\n\t\tindex := g.sequence[i]\n\t\titem := g.vertex[index]\n\t\tfor j := 0; j < len(item.edge); j++ {\n\t\t\tedge := item.edge[j]\n\t\t\tg.el[index] = g.vl[edge.to] - edge.weight\n\t\t\tif g.el[index] == g.ee[index] {\n\t\t\t\tg.keyActivities = append(g.keyActivities, [2]uint{index, edge.to})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (g *ALGraph) init() {\n\tg.sequence = g.sort()\n\tif !g.flag {\n\t\tfmt.Println(\"存在环\")\n\t\treturn\n\t}\n\tg.setVe()\n\tg.setVl()\n\tg.setEe()\n\tg.setEl()\n}\n\nfunc (g *ALGraph) setVertex(vertex []*VertexNode) {\n\tg.vertex = vertex\n\tg.init()\n}\n\nfunc main() {\n\tvertex := []*VertexNode{\n\t\t{\n\t\t\tname: 'A',\n\t\t\tin:   0,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     3,\n\t\t\t\t\tweight: 5,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tto:     2,\n\t\t\t\t\tweight: 4,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tto:     1,\n\t\t\t\t\tweight: 6,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'B',\n\t\t\tin:   1,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     4,\n\t\t\t\t\tweight: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'C',\n\t\t\tin:   1,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     4,\n\t\t\t\t\tweight: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'D',\n\t\t\tin:   1,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     5,\n\t\t\t\t\tweight: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'E',\n\t\t\tin:   2,\n\t\t\tedge: []*EdgeNode{\n\n\t\t\t\t{\n\t\t\t\t\tto:     7,\n\t\t\t\t\tweight: 7,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tto:     6,\n\t\t\t\t\tweight: 9,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'F',\n\t\t\tin:   1,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     7,\n\t\t\t\t\tweight: 4,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'G',\n\t\t\tin:   1,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     8,\n\t\t\t\t\tweight: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'H',\n\t\t\tin:   2,\n\t\t\tedge: []*EdgeNode{\n\t\t\t\t{\n\t\t\t\t\tto:     8,\n\t\t\t\t\tweight: 4,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: 'I',\n\t\t\tin:   2,\n\t\t\tedge: []*EdgeNode{},\n\t\t},\n\t}\n\tg := &ALGraph{}\n\tg.setVertex(vertex)\n\n\tfmt.Println(g.sequence)\n\tfmt.Println(g.ve)\n\tfmt.Println(g.vl)\n\tfmt.Println(g.ee)\n\tfmt.Println(g.el)\n\tfmt.Println(g.keyActivities)\n}\n")])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[0 1 2 4 6 3 5 7 8]\n[0 6 4 5 7 7 16 14 18]\n[0 6 6 8 7 10 16 14 18]\n[0 6 4 5 7 7 16 14 18]\n[0 6 6 8 7 10 16 14 0]\n[[0 1] [1 4] [4 7] [4 6] [6 8] [7 8]]\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);