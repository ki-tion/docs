(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{387:function(t,n,a){"use strict";a.r(n);var e=a(10),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构-栈-队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-栈-队列"}},[t._v("#")]),t._v(" "),n("center",[t._v("数据结构-栈&队列")])],1),t._v(" "),n("h2",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),n("h3",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("***后进先出***的线性表，要求只在***表尾***进行删除和插入操作。插入操作称为入栈或者压栈，删除操作称为出栈。不含任何数据叫做空栈。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("     ┌──────┐   <--- 栈顶（Top）\n     │   C  │   \n     ├──────┤   \n     │   B  │   \n     ├──────┤   \n     │   A  │   \n     ├──────┤   \n     │      │   \n     └──────┘   <--- 栈底（Bottom）\n    Stack\n")])])]),n("p",[t._v("入栈顺序A->B->C,出栈顺序C->B->A")]),t._v(" "),n("h3",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n)\n\ntype Stack struct {\n\tsize uint\n\ttop  *Ele\n}\ntype Ele struct {\n\tdata interface{}\n\tnext *Ele\n}\n\nfunc (s *Stack) Push(data interface{}) {\n\tele := &Ele{\n\t\tdata: data,\n\t\tnext: s.top,\n\t}\n\ts.top = ele\n\ts.size++\n}\nfunc (s *Stack) Pop() interface{} {\n\tif s.top == nil {\n\t\treturn nil\n\t}\n\tdata := s.top.data\n\ts.top = s.top.next\n\ts.size--\n\treturn data\n}\nfunc (s *Stack) Clear() {\n\ts.top = nil\n\ts.size = 0\n}\nfunc (s *Stack) Size() uint {\n\treturn s.size\n}\n\nfunc main() {\n\tstack := Stack{}\n\tstack.Push("第0个元素")\n\tstack.Push("第1个元素")\n\tstack.Push("第2个元素")\n\tstack.Push("第3个元素")\n\tstack.Push("第4个元素")\n\tfmt.Println(stack.Size())\n\tfmt.Println(stack.Pop())\n\tfmt.Println(stack.Pop())\n\tfmt.Println(stack.Pop())\n\tfmt.Println(stack.Pop())\n\tstack.Clear()\n\tfmt.Println(stack.Pop())\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("p",[t._v("输出")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("5\n第4个元素\n第3个元素\n第2个元素\n第1个元素\n<nil>  \n")])])]),n("h2",{attrs:{id:"队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),n("h3",{attrs:{id:"定义-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("只允许在一端进行插入操作，而在另一端进行删除操作的线性表。与栈相反，队列是一种***先进先出***的线性表")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("   ┌──────┐   <--- Front\n → │   A  │   \n   ├──────┤   \n → │   B  │   \n   ├──────┤   \n → │   C  │   \n   ├──────┤   \n   │      │   \n   └──────┘   <--- Rear\n   Queue\n")])])]),n("p",[t._v("进入队列顺序A->B->C,弹出队列顺序A->B->C")]),t._v(" "),n("h3",{attrs:{id:"实现-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n)\n\ntype Queue struct {\n\tsize  uint\n\tfront *Ele\n\trear  *Ele\n}\ntype Ele struct {\n\tdata interface{}\n\tnext *Ele\n}\n\nfunc (q *Queue) Push(data interface{}) {\n\tele := &Ele{\n\t\tdata: data,\n\t}\n\tif q.size == 0 {\n\t\tq.front = ele\n\t} else {\n\t\tq.rear.next = ele\n\t}\n\tq.rear = ele\n\tq.size++\n}\nfunc (q *Queue) Pop() interface{} {\n\tif q.size == 0 {\n\t\treturn nil\n\t}\n\tdata := q.front.data\n\tq.front = q.front.next\n\tq.size--\n    // 当前操作如果把最后一个元素弹了出去，队列就空了，将尾部重置成nil\n\tif q.size == 0 {\n\t\tq.rear = nil\n\t}\n\treturn data\n}\nfunc (q *Queue) Clear() {\n\tq.front = nil\n\tq.rear = nil\n\tq.size = 0\n}\nfunc (q *Queue) Size() uint {\n\treturn q.size\n}\n\nfunc main() {\n\tqueue := Queue{}\n\tqueue.Push("第0个元素")\n\tqueue.Push("第1个元素")\n\tqueue.Push("第2个元素")\n\tqueue.Push("第3个元素")\n\tqueue.Push("第4个元素")\n\tfmt.Println(queue.Size())\n\tfmt.Println(queue.Pop())\n\tfmt.Println(queue.Pop())\n\tfmt.Println(queue.Pop())\n\tfmt.Println(queue.Pop())\n\tqueue.Clear()\n\tfmt.Println(queue.Pop())\n}\n\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("p",[t._v("输出")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("5\n第0个元素\n第1个元素\n第2个元素\n第3个元素\n<nil>  \n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);