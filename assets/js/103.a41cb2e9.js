(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{385:function(t,n,e){"use strict";e.r(n);var r=e(10),a=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构-平衡二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-平衡二叉树"}},[t._v("#")]),t._v(" "),n("center",[t._v("数据结构-平衡二叉树")])],1),t._v(" "),n("h2",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("二叉平衡树（AVL tree）是一种自平衡二叉查找树，它是一棵空树或具有以下性质的二叉排序树：它的左子树和右子树的高度之差(平衡因子)的绝对值不超过1且它的左子树和右子树都是一颗平衡二叉树。")]),t._v(" "),n("p",[t._v("二叉平衡树的插入和删除操作需要维护树的平衡性，因此需要进行旋转操作。旋转操作可以分为左旋和右旋两种。")]),t._v(" "),n("p",[t._v("二叉平衡树是一种高效的二叉查找树，它具有良好的查找、插入和删除性能。但是，二叉平衡树的实现复杂度高，需要进行旋转操作来维护平衡性，可能会影响性能。")]),t._v(" "),n("h2",{attrs:{id:"思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),n("p",[t._v("除了插入和删除，其余部分和二叉排序树相同。每次插入或删除之后判断树是否平衡，如果不平衡，找到最小不平衡树，根据不平衡类型(不平衡类型分为：LL,LR,RR,RL)进行旋转。旋转分为左旋和右旋")]),t._v(" "),n("p",[t._v("LL类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    A\n   / \\\n  B   AR\n / \\  \nBL BR \n|\nX\n")])])]),n("p",[t._v("RR类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    A\n   / \\\n  AL   B\n      / \\\n     BL BR\n         |\n         X\n")])])]),n("p",[t._v("LR类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    A\n   / \\\n  B  AR\n / \\  \nBL  C \n   / \\\n  CL CR\n  |\n  X\n")])])]),n("p",[t._v("RL类型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    A\n   / \\\n  AL  B\n     / \\\n    c  BR\n   / \\\n  CL  CR\n  |\n  X\n")])])]),n("p",[t._v("具体来说")]),t._v(" "),n("ul",[n("li",[t._v("LL类型需要将最小不平衡子树进行右旋操作")]),t._v(" "),n("li",[t._v("RR类型需要将最小不平衡子树进行左旋操作")]),t._v(" "),n("li",[t._v("LR类型需要先将最小不平衡子树左子树进行左旋操作，再将最小不平衡子树进行右旋操作")]),t._v(" "),n("li",[t._v("RL类型需要先将最小不平衡子树右子树进行右旋操作，再将最小不平衡子树进行左旋操作")])]),t._v(" "),n("h3",{attrs:{id:"左旋操作步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#左旋操作步骤"}},[t._v("#")]),t._v(" 左旋操作步骤")]),t._v(" "),n("p",[t._v("左旋操作是将某个节点的右子树作为新的根节点，原根节点成为新的右子树的左子树。原根节点的左子树的右子树为源根节点的右子树")]),t._v(" "),n("h3",{attrs:{id:"右旋操作步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#右旋操作步骤"}},[t._v("#")]),t._v(" 右旋操作步骤")]),t._v(" "),n("p",[t._v("右旋操作是某个节点的左子树作为新的根节点，原根节点成为新的左子树的右子树。原根节点的右子树的左子树作为原根节点的右子树。")]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 平衡二叉树\npackage main\n\nimport (\n\t"fmt"\n\t"strconv"\n)\n\ntype Data struct {\n\tid    uint\n\tvalue string\n}\n\ntype Tree_node struct {\n\tparent *Tree_node\n\tleft   *Tree_node\n\tright  *Tree_node\n\tdata   *Data\n}\n\ntype Tree struct {\n\troot *Tree_node\n}\n\nfunc (t *Tree_node) Insert(data *Data) bool {\n\tif data.id == t.data.id {\n\t\treturn false\n\t} else if data.id < t.data.id {\n\t\tif t.left == nil {\n\t\t\tt.left = &Tree_node{t, nil, nil, data}\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn t.left.Insert(data)\n\t\t}\n\t} else {\n\t\tif t.right == nil {\n\t\t\tt.right = &Tree_node{t, nil, nil, data}\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn t.right.Insert(data)\n\t\t}\n\t}\n}\n\nfunc (t *Tree_node) Search_node(id uint) *Tree_node {\n\tif t.data.id == id {\n\t\treturn t\n\t}\n\tif id < t.data.id {\n\t\tif t.left == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn t.left.Search_node(id)\n\t} else {\n\t\tif t.right == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn t.right.Search_node(id)\n\t}\n}\n\nfunc (t *Tree_node) Search(id uint) *Data {\n\tnode := t.Search_node(id)\n\tif node == nil {\n\t\treturn nil\n\t}\n\treturn node.data\n}\nfunc (t *Tree_node) Delete(id uint) bool {\n\tnode := t.Search_node(id)\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.left == nil && node.right == nil {\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = nil\n\t\t} else {\n\t\t\tnode.parent.right = nil\n\t\t}\n\t\treturn true\n\t}\n\tif node.left == nil {\n\t\tnode.right.parent = node.parent\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = node.right\n\t\t} else {\n\t\t\tnode.parent.right = node.right\n\t\t}\n\t\treturn true\n\t}\n\tif node.right == nil {\n\t\tnode.left.parent = node.parent\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = node.left\n\t\t} else {\n\t\t\tnode.parent.right = node.left\n\t\t}\n\t\treturn true\n\t}\n\t// 左右子树都不为空\n\t// 找到左子树中最大的节点\n\tmax_node := node.left\n\tfor max_node.right != nil {\n\t\tmax_node = max_node.right\n\t}\n\tnode.data = max_node.data\n\tif max_node.left != nil {\n\t\tmax_node.data = max_node.left.data\n\t\tmax_node.left = nil\n\t} else {\n\t\tif max_node.parent.left == max_node {\n\t\t\tmax_node.parent.left = nil\n\t\t} else {\n\t\t\tmax_node.parent.right = nil\n\t\t}\n\t}\n\treturn true\n}\n\n/**\n*@returns 是否存在不平衡树 不平衡树路径\n */\nfunc (t *Tree_node) Is_balance() (bool, []*Tree_node) {\n\tcurrent_node_list := []*Tree_node{t}\n\tif t.left == nil && t.right == nil {\n\t\treturn false, current_node_list\n\t}\n\tr_path := []*Tree_node{}\n\tr_ok := false\n\tif t.right != nil {\n\t\tr_ok, r_path = t.right.Is_balance()\n\t\tif r_ok {\n\t\t\treturn r_ok, r_path\n\t\t}\n\t}\n\n\tl_path := []*Tree_node{}\n\tl_ok := false\n\tif t.left != nil {\n\t\tl_ok, l_path = t.left.Is_balance()\n\t\tif l_ok {\n\t\t\treturn l_ok, l_path\n\t\t}\n\t}\n\n\tl_path = append(current_node_list, l_path...)\n\tr_path = append(current_node_list, r_path...)\n\tdis := len(l_path) - len(r_path)\n\tif dis > 1 {\n\t\treturn true, l_path\n\t}\n\tif dis > 0 {\n\t\treturn false, l_path\n\t}\n\tif dis < -1 {\n\t\treturn true, r_path\n\t}\n\treturn false, r_path\n\n}\n\nfunc (t *Tree) Is_balance() (bool, []*Tree_node) {\n\tif t.root == nil {\n\t\treturn false, []*Tree_node{}\n\t}\n\treturn t.root.Is_balance()\n}\n\nfunc (t *Tree) Rotate_left(node *Tree_node) {\n\tparent := node.parent\n\tright := node.right\n\tright_left := right.left\n\tif parent != nil {\n\t\tif parent.left == node {\n\t\t\tparent.left = right\n\t\t} else {\n\t\t\tparent.right = right\n\t\t}\n\t} else {\n\t\tt.root = right\n\t}\n\tright.parent = parent\n\tnode.parent = right\n\tright.left = node\n\tnode.right = right_left\n\tif right_left != nil {\n\t\tright_left.parent = node\n\t}\n}\nfunc (t *Tree) Rotate_right(node *Tree_node) {\n\tparent := node.parent\n\tleft := node.left\n\tleft_right := left.right\n\tif parent != nil {\n\t\tif parent.left == node {\n\t\t\tparent.left = left\n\t\t} else {\n\t\t\tparent.right = left\n\t\t}\n\t} else {\n\t\tt.root = left\n\t}\n\tleft.parent = parent\n\tnode.parent = left\n\tleft.right = node\n\tnode.left = left_right\n\tif left_right != nil {\n\t\tleft_right.parent = node\n\t}\n}\nfunc (t *Tree) Rotate() {\n\tok, list := t.Is_balance()\n\tif !ok {\n\t\treturn\n\t}\n\tif list[0].left == list[1] {\n\t\t// LR\n\t\tif list[1].left != list[2] {\n\t\t\tt.Rotate_left(list[1])\n\t\t}\n\t\t// LL\n\t\tt.Rotate_right(list[0])\n\t} else {\n\t\t// RL\n\t\tif list[1].right != list[2] {\n\t\t\tt.Rotate_right(list[1])\n\t\t}\n\t\t// RR\n\t\tt.Rotate_left(list[0])\n\t}\n}\n\nfunc (t *Tree) Insert(data *Data) bool {\n\tif t.root == nil {\n\t\tt.root = &Tree_node{nil, nil, nil, data}\n\t\treturn true\n\t}\n\tif t.root.Insert(data) {\n\t\tt.Rotate()\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc (t *Tree) Search(id uint) *Data {\n\tif t.root == nil {\n\t\treturn nil\n\t}\n\treturn t.root.Search(id)\n}\n\nfunc (t *Tree) Delete(id uint) bool {\n\tif t.root == nil {\n\t\treturn false\n\t}\n\tif id == t.root.data.id {\n\t\tleft := t.root.left\n\t\tright := t.root.right\n\n\t\tif left == nil && right == nil {\n\t\t\tt.root = nil\n\t\t\tt.Rotate()\n\t\t\treturn true\n\t\t}\n\t\tif left == nil {\n\t\t\tt.root = right\n\t\t\tt.Rotate()\n\t\t\treturn true\n\t\t}\n\t\tif right == nil {\n\t\t\tt.root = left\n\t\t\tt.Rotate()\n\t\t\treturn true\n\t\t}\n\t\t// 左右子树都不为空\n\t\t// 找到左子树中最大的节点\n\t\tmax_node := t.root.left\n\t\tfor max_node.right != nil {\n\t\t\tmax_node = max_node.right\n\t\t}\n\t\tt.root.data = max_node.data\n\t\tif max_node.left != nil {\n\t\t\tmax_node.data = max_node.left.data\n\t\t\tmax_node.left = nil\n\t\t} else {\n\t\t\tif max_node.parent.left == max_node {\n\t\t\t\tmax_node.parent.left = nil\n\t\t\t} else {\n\t\t\t\tmax_node.parent.right = nil\n\t\t\t}\n\t\t}\n\t\tt.Rotate()\n\t\treturn true\n\t}\n\tif t.root.Delete(id) {\n\t\tt.Rotate()\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc (t *Tree) Update(data *Data) {\n\tnode := t.root.Search_node(data.id)\n\tif node == nil {\n\t\treturn\n\t}\n\tnode.data = data\n}\n\nfunc (t *Tree_node) print() {\n\tif t.left != nil {\n\t\tfmt.Println(strconv.Itoa(int(t.data.id)) + "left->" + strconv.Itoa(int(t.left.data.id)))\n\t\tt.left.print()\n\t}\n\tif t.right != nil {\n\t\tfmt.Println(strconv.Itoa(int(t.data.id)) + "right->" + strconv.Itoa(int(t.right.data.id)))\n\t\tt.right.print()\n\t}\n}\n\nfunc main() {\n\ttree := &Tree{}\n\ttree.Insert(&Data{id: 1, value: "啊大"})\n\ttree.Insert(&Data{id: 2, value: "啊二"})\n\ttree.Insert(&Data{id: 3, value: "啊三"})\n\ttree.Insert(&Data{id: 4, value: "啊四"})\n\ttree.Insert(&Data{id: 5, value: "啊五"})\n\ttree.Insert(&Data{id: 6, value: "啊六"})\n\ttree.Insert(&Data{id: 7, value: "啊七"})\n\ttree.root.print()\n\ttree.Delete(5)\n\ttree.Delete(6)\n\ttree.Delete(7)\n\tfmt.Println("---------")\n\ttree.root.print()\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("4left->2\n2left->1 \n2right->3\n4right->6\n6left->5 \n6right->7\n---------\n3left->2 \n2left->1 \n3right->4\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);