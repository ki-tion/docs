(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{384:function(t,n,e){"use strict";e.r(n);var a=e(10),r=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构-二叉排序树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-二叉排序树"}},[t._v("#")]),t._v(" "),n("center",[t._v("数据结构-二叉排序树")])],1),t._v(" "),n("p",[t._v("二叉排序树（Binary Search Tree，BST）是一种数据结构，它是一种二叉树，其中每个节点的值都大于或等于其左子树中的所有值，小于或等于其右子树中的所有值。")]),t._v(" "),n("p",[t._v("示例")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    20\n   / \\\n  15  25\n / \\  / \\\n10 17 22 30\n")])])]),n("h2",{attrs:{id:"性质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性质"}},[t._v("#")]),t._v(" 性质")]),t._v(" "),n("ul",[n("li",[t._v("每个节点的值都大于或等于其左子树中的所有值")]),t._v(" "),n("li",[t._v("每个节点的值都小于或等于其右子树中的所有值")]),t._v(" "),n("li",[t._v("左子树和右子树都是二叉排序树")])]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("p",[t._v("需要注意删除节点功能，可能存在4种情况：")]),t._v(" "),n("ul",[n("li",[t._v("被删除节点没有子节点")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("直接删除节点即可")])])]),t._v(" "),n("li",[t._v("被删除节点只有左子节点")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("将左子节点提升到删除节点的父节点上")])])]),t._v(" "),n("li",[t._v("被删除节点只有右子节点")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("将右子节点提升到删除节点的父节点上")])])]),t._v(" "),n("li",[t._v("被删除节点有左右子节点")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("找到删除节点的左子树中的最大节点，或者右子树中的最小节点，用该节点替换删除节点")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("若替换的子节点也具有其子节点，将其子节点替换其节点")])])])]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n\t"strconv"\n)\n\ntype Data struct {\n\tid    uint\n\tvalue string\n}\n\ntype TreeNode struct {\n\tparent *TreeNode\n\tleft   *TreeNode\n\tright  *TreeNode\n\tdata   *Data\n}\n\ntype Tree struct {\n\troot *TreeNode\n}\n\nfunc (t *TreeNode) Insert(data *Data) bool {\n\tif data.id == t.data.id {\n\t\treturn false\n\t} else if data.id < t.data.id {\n\t\tif t.left == nil {\n\t\t\tt.left = &TreeNode{t, nil, nil, data}\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn t.left.Insert(data)\n\t\t}\n\t} else {\n\t\tif t.right == nil {\n\t\t\tt.right = &TreeNode{t, nil, nil, data}\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn t.right.Insert(data)\n\t\t}\n\t}\n}\n\nfunc (t *TreeNode) SearchNode(id uint) *TreeNode {\n\tif t.data.id == id {\n\t\treturn t\n\t}\n\tif id < t.data.id {\n\t\tif t.left == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn t.left.SearchNode(id)\n\t} else {\n\t\tif t.right == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn t.right.SearchNode(id)\n\t}\n}\n\nfunc (t *TreeNode) Search(id uint) *Data {\n\tnode := t.SearchNode(id)\n\tif node == nil {\n\t\treturn nil\n\t}\n\treturn node.data\n}\nfunc (t *TreeNode) Delete(id uint) {\n\tnode := t.SearchNode(id)\n\tif node == nil {\n\t\treturn\n\t}\n\tif node.left == nil && node.right == nil {\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = nil\n\t\t} else {\n\t\t\tnode.parent.right = nil\n\t\t}\n\t\treturn\n\t}\n\tif node.left == nil {\n        node.right.parent = node.parent\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = node.right\n\t\t} else {\n\t\t\tnode.parent.right = node.right\n\t\t}\n\t\treturn\n\t}\n\tif node.right == nil {\n        node.left.parent = node.parent\n\t\tif node.parent.left == node {\n\t\t\tnode.parent.left = node.left\n\t\t} else {\n\t\t\tnode.parent.right = node.left\n\t\t}\n\t\treturn\n\t}\n\t// 左右子树都不为空\n\t// 找到左子树中最大的节点\n\tmaxNode := node.left\n\tfor maxNode.right != nil {\n\t\tmaxNode = maxNode.right\n\t}\n\tnode.data = maxNode.data\n\tif maxNode.left != nil {\n\t\tmaxNode.data = maxNode.left.data\n\t\tmaxNode.left = nil\n\t} else {\n\t\tif maxNode.parent.left == maxNode {\n\t\t\tmaxNode.parent.left = nil\n\t\t} else {\n\t\t\tmaxNode.parent.right = nil\n\t\t}\n\t}\n}\n\nfunc (t *Tree) Insert(data *Data) bool {\n\tif t.root == nil {\n\t\tt.root = &TreeNode{nil, nil, nil, data}\n\t\treturn true\n\t}\n\treturn t.root.Insert(data)\n\n}\n\nfunc (t *Tree) Search(id uint) *Data {\n\tif t.root == nil {\n\t\treturn nil\n\t}\n\treturn t.root.Search(id)\n}\n\nfunc (t *Tree) Delete(id uint) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tif id == t.root.data.id {\n\t\tleft := t.root.left\n\t\tright := t.root.right\n\n\t\tif left == nil && right == nil {\n\t\t\tt.root = nil\n\t\t\treturn\n\t\t}\n\t\tif left == nil {\n\t\t\tt.root = right\n\t\t\treturn\n\t\t}\n\t\tif right == nil {\n\t\t\tt.root = left\n\t\t\treturn\n\t\t}\n\t\t// 左右子树都不为空\n\t\t// 找到左子树中最大的节点\n\t\tmaxNode := t.root.left\n\t\tfor maxNode.right != nil {\n\t\t\tmaxNode = maxNode.right\n\t\t}\n\t\tt.root.data = maxNode.data\n\t\tif maxNode.left != nil {\n\t\t\tmaxNode.data = maxNode.left.data\n\t\t\tmaxNode.left = nil\n\t\t} else {\n\t\t\tif maxNode.parent.left == maxNode {\n\t\t\t\tmaxNode.parent.left = nil\n\t\t\t} else {\n\t\t\t\tmaxNode.parent.right = nil\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\tt.root.Delete(id)\n}\n\nfunc (t *Tree) Update(data *Data) {\n\tnode := t.root.SearchNode(data.id)\n\tif node == nil {\n\t\treturn\n\t}\n\tnode.data = data\n}\n\nfunc (t *Tree) Console() {\n\tl1 := []*TreeNode{\n\t\tt.root,\n\t}\n\tl2 := []*TreeNode{}\n\tstr := ""\n\tfor len(l1) > 0 {\n\t\tnode := l1[0]\n\t\tl1 = l1[1:]\n\t\tstr += strconv.Itoa(int(node.data.id)) + ","\n\t\tif node.left != nil {\n\t\t\tl2 = append(l2, node.left)\n\t\t}\n\t\tif node.right != nil {\n\t\t\tl2 = append(l2, node.right)\n\t\t}\n\t\tif len(l1) == 0 {\n\t\t\tstr += "\\n"\n\t\t\tl1 = l2\n\t\t\tl2 = []*TreeNode{}\n\t\t}\n\t}\n\tfmt.Println(str)\n}\n\nfunc main() {\n\tlist := []*Data{\n\t\t{\n\t\t\tid:    70,\n\t\t\tvalue: "root",\n\t\t},\n\t\t{\n\t\t\tid:    67,\n\t\t\tvalue: "A",\n\t\t},\n\t\t{\n\t\t\tid:    105,\n\t\t\tvalue: "B",\n\t\t},\n\t\t{\n\t\t\tid:    46,\n\t\t\tvalue: "C",\n\t\t},\n\t\t{\n\t\t\tid:    100,\n\t\t\tvalue: "D",\n\t\t},\n\t\t{\n\t\t\tid:    115,\n\t\t\tvalue: "E",\n\t\t},\n\t\t{\n\t\t\tid:    99,\n\t\t\tvalue: "F",\n\t\t},\n\t\t{\n\t\t\tid:    104,\n\t\t\tvalue: "G",\n\t\t},\n\t\t{\n\t\t\tid:    110,\n\t\t\tvalue: "H",\n\t\t},\n\t\t{\n\t\t\tid:    103,\n\t\t\tvalue: "I",\n\t\t},\n\t\t{\n\t\t\tid:    108,\n\t\t\tvalue: "J",\n\t\t},\n\t\t{\n\t\t\tid:    112,\n\t\t\tvalue: "K",\n\t\t},\n\t\t{\n\t\t\tid:    113,\n\t\t\tvalue: "L",\n\t\t},\n\t\t{\n\t\t\tid:    114,\n\t\t\tvalue: "M",\n\t\t},\n\t}\n\ttree := &Tree{}\n\tfor i := 0; i < len(list); i++ {\n\t\ttree.Insert(list[i])\n\t}\n\tfmt.Println(tree.Search(115))\n\ttree.Delete(112)\n\ttree.Console()\n\ttree.Insert(&Data{\n\t\tid:    112,\n\t\tvalue: "K",\n\t})\n\ttree.Console()\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("&{115 E}\n70,\n67,105,\n46,100,115,\n99,104,110,\n103,108,113,\n114,\n\n70,\n67,105,\n46,100,115,\n99,104,110,\n103,108,113,\n112,114,\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);