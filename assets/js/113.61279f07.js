(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{396:function(t,n,s){"use strict";s.r(n);var a=s(10),i=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"算法-堆排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法-堆排序"}},[t._v("#")]),t._v(" "),n("center",[t._v("算法-堆排序")])],1),t._v(" "),n("h2",{attrs:{id:"前置名词解释"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前置名词解释"}},[t._v("#")]),t._v(" 前置名词解释")]),t._v(" "),n("ul",[n("li",[t._v("满二叉树: 每一层节点都达到最大值的二叉树")]),t._v(" "),n("li",[t._v("完全二叉树: 节点数小于等于满二叉树，节点顺序和满二叉树一一对应")]),t._v(" "),n("li",[t._v("堆: 一种特殊的完全二叉树。 每个结点的值都大于或等于其左右孩子结点的值(大根堆)，或每个结点的值都小于或等于其左右孩子结点的值(小根堆)。")])]),t._v(" "),n("h2",{attrs:{id:"基本思想"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本思想"}},[t._v("#")]),t._v(" 基本思想")]),t._v(" "),n("p",[t._v("用一个确定数列生成的堆也是确定的，改变该数列元素的顺序，则生成的堆也会改变。将数列调整成可以生成大根堆的顺序，再以大(小)根堆的性质直接选出最大(小)值进行排序。")]),t._v(" "),n("p",[t._v("由二叉树的性质可知:")]),t._v(" "),n("ul",[n("li",[t._v("列表元素个数/2即是最后一个堆节点的索引")]),t._v(" "),n("li",[t._v("堆的序号*2是该堆第一个子元素")])]),t._v(" "),n("h3",{attrs:{id:"具体步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#具体步骤"}},[t._v("#")]),t._v(" 具体步骤")]),t._v(" "),n("ul",[n("li",[t._v("对待排序数列进行调整，使其可以直接创建大根堆")]),t._v(" "),n("li",[t._v("取出待排数列中最大者(第一个元素)，将之移走")]),t._v(" "),n("li",[t._v("重复执行以上步骤，直到待排序数列只剩下一个元素")])]),t._v(" "),n("p",[t._v("注意:堆排序不是真的生成堆，而是"),n("strong",[t._v("生成可以直接创建出大根堆的数列")]),t._v("，根据堆的特性,每次选出最大值将之移走，并重复步骤至待排序数列只剩下一个元素。再简而言之其核心是每次选出待排序数列的最大值，只是其选出最大值的方式用到了堆的特性。")]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport "fmt"\n\n/**\n* 功能:微调待排序数列，方便直接生成大根堆\n* 原理1:满二叉树的层数n与该层元素个数关系2的n-1次方\n* 原理2:满二叉树第n层元素个数是n-1层的2倍\n* 原理3:列表元素个数/2即是最后一个堆，直接从该点倒退即可依次处理堆\n* 原理4:堆的序号*2是该堆第一个子元素\n */\nfunc sift(list []int, end int) {\n\tlength := len(list)\n\tif length <= 1 {\n\t\treturn\n\t}\n\tif end > length {\n\t\treturn\n\t}\n\t// 从最后一个堆(原理3)开始处理\n\tfor k := end / 2; k >= 0; k-- {\n\t\ti := k     // 当前处理堆元素在待排序数列中的下标\n\t\tj := 2 * i // 当前处理堆的第一个子元素(原理4)\n\t\tfor j < end {\n\t\t\t// j是堆的第一个子元素，堆可能还会有第二个子元素，即j < end时\n\t\t\t// 选出两个子元素中较大的一个的下标\n\t\t\tif j < end-1 && list[j] < list[j+1] {\n\t\t\t\tj++\n\t\t\t}\n\n\t\t\t// 如果子元素大的一个比本节点大，交换\n            // 本质来说是选出当前节点、左子节点和右子节点中最大的一个，并使其为父节点\n\t\t\tif list[j] > list[i] {\n\t\t\t\tlist[j], list[i] = list[i], list[j]\n\t\t\t}\n\n\t\t\t// 调整了堆，可能会打破其子堆(如果有)的平衡\n\t\t\t// 重复步骤，调整其子堆\n\t\t\ti = j\n\t\t\tj = 2 * i\n\t\t}\n\t}\n}\n\nfunc sort(list []int) {\n\tlength := len(list)\n\tif length <= 1 {\n\t\treturn\n\t}\n\tfor i := length; i > 1; i-- {\n\t\tsift(list, i)\n\t\tlist[0], list[i-1] = list[i-1], list[0]\n\t}\n}\nfunc main() {\n\tlist := []int{49, 38, 65, 97, 76, 13, 69, 48, 22}\n\tsort(list)\n\tfmt.Println(list)\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[13 22 38 48 49 65 69 76 97]\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);