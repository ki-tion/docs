(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{400:function(t,n,a){"use strict";a.r(n);var r=a(10),s=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"算法-汉诺塔"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法-汉诺塔"}},[t._v("#")]),t._v(" "),n("center",[t._v("算法-汉诺塔")])],1),t._v(" "),n("h2",{attrs:{id:"玩法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#玩法"}},[t._v("#")]),t._v(" 玩法")]),t._v(" "),n("p",[t._v("有三个柱子，初始时第一个柱子有n个圆盘，从小到大依次排列。需要把所有圆盘从一个柱子移动到另一个柱子，期间必须满足:")]),t._v(" "),n("ul",[n("li",[t._v("一次只能移动一个圆盘")]),t._v(" "),n("li",[t._v("如果有多个圆盘重叠，只能移动最上面的圆盘")]),t._v(" "),n("li",[t._v("移动的大圆盘不能在小圆盘之上")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("         |                 |                 |\n        ===                |                 |\n       =====               |                 |\n      =======              |                 |\n     =========             |                 |\n    ===========            |                 |\n   =============           |                 |\n -----------------  -----------------  -----------------\n       源柱              辅助柱             目标柱\n")])])]),n("h2",{attrs:{id:"思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),n("p",[t._v("将最上面个圆盘到倒数第二个圆盘看作一个整体,为了方便命名为"),n("code",[t._v("X")]),t._v("，那么要完成游戏需要3步:")]),t._v(" "),n("ul",[n("li",[t._v("将"),n("code",[t._v("X")]),t._v("移动到辅助柱")]),t._v(" "),n("li",[t._v("将最后一个圆盘移动到目标柱")]),t._v(" "),n("li",[t._v("将"),n("code",[t._v("X")]),t._v("移动到目标柱")])]),t._v(" "),n("p",[t._v("那么如何将"),n("code",[t._v("X")]),t._v("移动到辅助柱呢,"),n("code",[t._v("X")]),t._v("是多个圆盘的合称?将"),n("code",[t._v("X")]),t._v("当成完整的圆盘数，重复上一个动作即可。需要注意重复动作时,n-1的辅助柱是n-2的目标柱，以此类推")]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('package main\n\nimport (\n\t"fmt"\n\t"strconv"\n)\n\n/**\n* @parm n 第几个圆盘\n* @parm source 源柱\n* @parm auxiliary 辅助柱\n* @parm target 目标柱\n**/\n// 这里的n可以想象成端一堆叠起来的盘子,把最下面的盘子端起来就可以看成把所有盘子端起来移动位置\n// n -1 就可以理解成把n - 1及以上的盘子端起来移动\nfunc hanoi(n uint, source rune, auxiliary rune, target rune) {\n\tif n > 0 {\n\t\t// 将n的前一个放到辅助柱暂时储存\n\t\thanoi(n-1, source, target, auxiliary)\n\t\tfmt.Println("圆盘" + strconv.Itoa(int(n)) + "从" + string(source) + "柱" + "转移到" + string(target) + "柱")\n\t\t// 将n的前一个从辅助柱放到目标柱\n\t\thanoi(n-1, auxiliary, source, target)\n\t}\n}\n\nfunc main() {\n\tsource := \'A\' // 初始源柱\n\tauxiliary := \'B\'\n\ttarget := \'C\'\n\thanoi(3, source, auxiliary, target)\n}\n')])])]),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[t._v("go run ."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("main.go\n")])])]),n("p",[t._v("输出")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("圆盘1从A柱转移到C柱\n圆盘2从A柱转移到B柱\n圆盘1从C柱转移到B柱\n圆盘3从A柱转移到C柱\n圆盘1从B柱转移到A柱\n圆盘2从B柱转移到C柱\n圆盘1从A柱转移到C柱\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);